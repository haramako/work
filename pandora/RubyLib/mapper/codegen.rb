# coding: utf-8
# frozen_string_literal: true

#
# C#用コードジェネレータ
#

require 'pp'
require 'open3'
require 'active_support/inflector'

module CsharpGenerator
  class Nested
    attr_reader :name
    attr_reader :children

    def initialize(name, *args)
      @name = name
      @children = []
      init(*args)
    end

    def init(*args); end

    def parse(&block)
      instance_eval(&block) if block
      self
    end

    def generate(out)
      @children.each do |c|
        c.generate(out)
        out << ""
      end
    end
  end

  module DSL
    ASTYLE = "#{__dir__}/../../../Tools/Bin/astyle.exe"

    HEADER = <<~EOT
      // Generated by the codegen.rb.  DO NOT EDIT!

      using System;
      using System.Linq;
      using System.Collections.Generic;
      using System.Collections.ObjectModel;
      using ToydeaCabinet;

EOT

    def self.headers
      @headers ||= []
    end

    def self.mappers
      @mappers ||= []
    end

    def self.generate
      out = []
      out += headers
      mappers.each do |ns|
        ns.generate(out)
      end
      src = out.join("\n")

      src, stat = Open3.capture2("#{ASTYLE} --options=#{__dir__}/../../../.astyle", stdin_data: src) # フォーマットする
      if stat.exitstatus != 0
        puts src
        raise "atyle failed"
      end

      HEADER + src
    end

    def emit(str)
      DSL.headers << str
    end

    def mapper(name, &block)
      m = Mapper.new(name)
      DSL.mappers << m
      m.parse(&block)
    end
  end

  # マッパー
  class Mapper < Nested
    attr_reader :tags

    def init(*_args)
      @tags = {}
      @name = @name.camelize
    end

    def generate(out)
      if @name && !@name.empty?
        out << "public partial class #{@name} : MapperBase {"

        gen_init(out)
        gen_load(out)

        super(out)

        out << "}"
      else
        super(out)
      end
    end

    def gen_init(out)
      out << "public #{@name}(){"
      @children.each { |c| c.gen_init(out) }
      out << "}"
      out << ''
    end

    def gen_load(out)
      out << "public override void LoadFromCabinet(Cabinet c){"
      @children.each { |c| c.gen_load_clear(out) }
      out << "c_ = c;"
      out << "foreach( var r in c.All() ){"
      out << "var tag = (int)(r.Key >> 56);"
      out << "switch(tag){"
      @children.each { |c| c.gen_load_case(out) }
      out << "default:"
      out << " break;"
      out << "}"
      out << "}"
      out << "}"
      out << ''
    end

    def column(tag, type, name, *opt, &block)
      item = Column.new(name, :single, tag, type, *opt).parse(&block)
      @children << item
      @tags[item.tag] = item
    end

    def list(tag, type, name, *opt, &block)
      item = Column.new(name, :list, tag, type, *opt).parse(&block)
      @children << item
      @tags[item.tag] = item
    end
  end

  class Column < Nested
    attr_reader :kind, :type, :tag

    def init(kind, tag, type, *args)
      raise "tag must Integer but #{tag}" unless tag.is_a? Integer
      @name = @name
      @kind = kind
      @type = type
      @tag = tag
      @cs_name = @name.camelize
      @cs_type = @type.to_s.camelize
      case kind
      when :single
        # DO NOTHING
        nil
      when :list
        @index = args[0]
      else
        raise "invalid type #{type}"
      end
    end

    def generate(out)
      case @kind
      when :single
        out << "#{@cs_type} #{@cs_name}_;"
        out << "public #{@cs_type} #{@cs_name} { get { return #{@cs_name}_; } }"
        out << "public void Update#{@cs_name}(#{@cs_type} val){ #{@cs_name}_ = val; c_.Put(Get#{@cs_name}CabinetKey(), Serializer.Serialize(val)); }"
        out << "public CabinetKey Get#{@cs_name}CabinetKey(){ return new CabinetKey().Store(8, #{@tag}); }"
        super(out)
      when :list
        out << "Dictionary<int, #{@cs_type}> #{@cs_name}_ = new Dictionary<int, #{@cs_type}>();"
        out << "public ReadOnlyDictionary<int, #{@cs_type}> #{@cs_name} { get; private set; }"
        out << "public void Update#{@cs_name.singularize}(#{@cs_type} val){ #{@cs_name}_[val.Id] = val; c_.Put(Get#{@cs_name.singularize}CabinetKey(val.Id), Serializer.Serialize(val)); }"
        out << "public void Delete#{@cs_name.singularize}(int id){ #{@cs_name}_.Remove(id); }"
        out << "public CabinetKey Get#{@cs_name.singularize}CabinetKey(int id){ return new CabinetKey().Store(8, #{@tag}).Store(32, (uint)id); }"
        out << "public CabinetKey Get#{@cs_name.singularize}CabinetPrefix(){ return new CabinetKey().Store(8, #{@tag}); }"
        super(out)
      else
        raise
      end
    end

    def gen_init(out)
      case @kind
      when :single
        # DO NOTHING
        nil
      when :list
        out << "#{@cs_name} = new ReadOnlyDictionary<int,#{@cs_type}>(#{@cs_name}_);"
      else
        raise
      end
    end

    def gen_load_clear(out)
      case @kind
      when :single
        out << "#{@cs_name}_ = default(#{@cs_type});"
      when :list
        out << "#{@cs_name}_.Clear();"
      else
        raise
      end
    end

    def gen_load_case(out)
      out << "case #{@tag}: {"
      case @kind
      when :single
        out << "#{@cs_name}_ = Serializer.Deserialize#{@cs_type}(r.Data);"
      when :list
        out << "var e = Serializer.DeserializeMessage<#{@cs_type}>(r.Data);"
        out << "#{@cs_name}_[e.Id] = e;"
      else
        raise
      end
      out << "} break;"
    end
  end
end

include CsharpGenerator::DSL
