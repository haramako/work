
-voidをいれる
-returnをちゃんとする
-callの複数引数化
-index/pget/psetの最適化
-配列の初期化
-include_binを追加
-indexのサイズを反映
-aレジスタの最適化
-/,*,&,|,&&,||の実装
-型補完をいれる

*lambdaを値として取れるようにする（引数の汎用化が必須)
*signedの導入
*配列サイズの省略(初期化式ありのみ）
*ブランチが+-128以上にとべるように
*sizeof()の実装
*ステータスレジスタ最適化
*メモリの重複割り当て
*';'省略
*'('省略
*マクロ
*スタックを使用できるときはするようにする
*アセンブラでのシンボルをもうちょっとわかりやすく

1 + 2
  -> [ 1, 2 ]."+"(){}
    -> [:'+', [1:int,2:int], [], {}]

obj.method( x, y )
  -> [ obj ].method( x, y ){}
    -> [:method, [obj:class], [:x, :y], {}]

[a,b].remove()
    -> [ a:obj, b:obj ].remove(){}
      -> [:remove, [a:obj, b:obj], [], {}]

some_func( a, b + 1 ){}
  -> [].some_func( a, b )
    -> [:some_func, [], [:a, :b] , {} ]

a.hoge().fuga()
  -> [a].hoge(
  

{}はタプル
タプルのメソッドはオーバーロード可能

構成要素は、
  [:call ,メソッド名, タプル(評価済み), 引数リスト(未評価), ブロックリスト ]
メソッドは、通常の関数か、マクロ
マクロの場合は、引数は評価されない。通常の関数の場合は評価されてから送られる。


**掛け算

  a * b
= ( (a^2 + 2ab + b^2) - ( a^2 - 2ab + b^2 ) ) / 4
= ( (a+b)^2 - (a-b)^2) / 4
= (a+b)^2 / 4 - (a-b)^2 / 4

**クロック数
CPU = 1.79MHz

水平同期あたりクロック数 =   1,243 clock
垂直同期あたりクロック数 = 298,363 clock
vblankクロック数         =  19,890 clock

60*240 = 14400 水平同期/秒

