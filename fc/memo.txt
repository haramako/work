
-voidをいれる
-returnをちゃんとする
-callの複数引数化
-index/pget/psetの最適化
-配列の初期化
-include_binを追加
-indexのサイズを反映
-aレジスタの最適化
-/,*,&,|,&&,||の実装
-型補完をいれる

*signedの導入
*配列サイズの省略(初期化式ありのみ）
*ブランチが+-128以上にとべるように
*sizeof()の実装
*ステータスレジスタ最適化
*メモリの重複割り当て
*';'省略
*'('省略
*マクロ
*スタックを使用できるときはするようにする
*アセンブラでのシンボルをもうちょっとわかりやすく

1 + 2
  -> [ 1, 2 ]."+"(){}
    -> [:'+', [1:int,2:int], [], {}]

obj.method( x, y )
  -> [ obj ].method( x, y ){}
    -> [:method, [obj:class], [:x, :y], {}]

[a,b].remove()
    -> [ a:obj, b:obj ].remove(){}
      -> [:remove, [a:obj, b:obj], [], {}]

some_func( a, b + 1 ){}
  -> [].some_func( a, b )
    -> [:some_func, [], [:a, :b] , {} ]

a.hoge().fuga()
  -> [a].hoge(
  

{}はタプル
タプルのメソッドはオーバーロード可能

構成要素は、
  [:call ,メソッド名, タプル(評価済み), 引数リスト(未評価), ブロックリスト ]
メソッドは、通常の関数か、マクロ
マクロの場合は、引数は評価されない。通常の関数の場合は評価されてから送られる。


**掛け算

a * b = f( a + b ) - f( a - b )
(a * b) mod256 = ( f( a + b ) - f( a - b ) ) mod 256

f(x) = x * x / 4

((a mod256) * (b mod256) mod256)
  = { [ f(a + b) mod256 ] - [ f(a-b) mod256 ] } mod 256
  = ((a^2 + 2ab + b^2)/4 mod256) - ((a^2 - 2ab + b^2)/4 mod 256)


f( a mod 256 + b mod 256 )
  = ( ( A + B ) * ( A + B )) / 4
  = ( A^2 + 2AB + B^2 ) / 4

f( a + b )
  = ( a^2 + 2ab + b^2 ) / 4
  = ( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) / 4
  = ( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4
   +( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4

   
  = {  ( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4
      +( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4 }
   -{  ( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4
      +( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4 }

  = {  ( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4
      +( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4 } mod 256
   -{  ( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4
      +( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4 } mod 256

  =    ( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4     mod 256
      +( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4 mod 256
      -( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4     mod 256
      -( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) mod 4 / 4 mod 256

  =    ( (A^2 + 2AA' + A'^2 )   +   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4     mod 256
      -( (A^2 + 2AA' + A'^2 )   -   2(AB+AB'+A'B+A'B')   +   (B^2 + 2BB' + B'^2 ) ) div 4     mod 256

  =    ( + 2(AB+AB'+A'B+A'B') ) div 4     mod 256
      -( - 2(AB+AB'+A'B+A'B') ) div 4     mod 256

  =    AB mod 256


 10001000
x10001000


**クロック数
CPU = 1.79MHz

水平同期あたりクロック数 =   1,243 clock
垂直同期あたりクロック数 = 298,363 clock
vblankクロック数         =  19,890 clock

60*240 = 14400 水平同期/秒

