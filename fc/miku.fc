options ( inesprg: 1, // プログラムにいくつのバンクを使うか。今は１つ。
          ineschr: 1, // グラフィックデータにいくつのバンクを使うか。今は１つ。
          inesmir: 0, // 水平ミラーリング
          inesmap: 0  // マッパー。０番にする。
          );

include( "miku.asm" );
include( "nes.fc" );

const BG:int[1] options ( file:'miku.chr', char_bank: 0 );


var vsync_flag:int;
var ppu_ctrl1_bak:int = 0b10000000;
var ppu_ctrl2_bak:int = 0b00011110;
var ppu_scroll1:int = 0;
var ppu_scroll2:int = 0;

var gr_idx:int = 0;
var gr_to_buf:int16[4];
var gr_from_buf:int*[4];
var gr_size_buf:int[4];
var gr_sprite_idx:int = 0;
var gr_sprite_buf:int[256] options (address:0x0700);

var pad_a:int;
var pad_b:int;
var pad_select:int;
var pad_start:int;
var pad_up:int;
var pad_down:int;
var pad_left:int;
var pad_right:int;

function interrupt():void
{
  // 描画の更新を行う
  if( vsync_flag ){
    
    SPRITE_DMA = 7;
    gr_sprite_idx = 0;
    
    var i:int = 0;
    while( i < gr_idx ){
      ppu_put( gr_to_buf[i], gr_from_buf[i], gr_size_buf[i] );
      i += 1;
    }
    gr_idx = 0;
    vsync_flag = 0;
  }
  
  PPU_SCROLL = ppu_scroll1;
  PPU_SCROLL = ppu_scroll2;
  PPU_CTRL1 = ppu_ctrl1_bak;
  PPU_CTRL2 = ppu_ctrl2_bak;

}

function wait_vsync():void
{
  while( gr_sprite_idx < 255 ){
    gr_sprite_buf[gr_sprite_idx] = 0;
    gr_sprite_idx += 1;
  }
  vsync_flag = 1;
  while( vsync_flag ){}
}

function ppu_lock():void
{
  PPU_CTRL1 = 0b00000000;
  PPU_CTRL2 = 0b00000000;
}

function ppu_unlock():void
{
  PPU_CTRL1 = 0b10000000;
  wait_vsync();
}

function ppu_put( to:int16, from:int*, size:int ):void options ( extern:true ) {}

function gr_add( to:int16, from:int*, size:int):void
{
  gr_from_buf[gr_idx] = from;
  gr_to_buf[gr_idx] = to;
  gr_size_buf[gr_idx] = size;
  gr_idx += 1;
}

function gr_sprite( x:int, y:int, pat:int, mode:int ):void
{
  var p:int = gr_sprite_idx;
  gr_sprite_buf[p] = y;
  gr_sprite_buf[p+1] = pat;
  gr_sprite_buf[p+2] = mode;
  gr_sprite_buf[p+3] = x;
  gr_sprite_idx += 4;
}

function gr_sprite2x2( x:int, y:int, pat:int, mode:int ):void
{
  var p:int = gr_sprite_idx;
  gr_sprite_buf[p] = y;
  gr_sprite_buf[p+1] = pat;
  gr_sprite_buf[p+2] = mode;
  gr_sprite_buf[p+3] = x;
  
  gr_sprite_buf[p+4] = y;
  gr_sprite_buf[p+5] = pat+1;
  gr_sprite_buf[p+6] = mode;
  gr_sprite_buf[p+7] = x+8;
  
  gr_sprite_buf[p+8] = y+8;
  gr_sprite_buf[p+9] = pat+16;
  gr_sprite_buf[p+10] = mode;
  gr_sprite_buf[p+11] = x;
  
  gr_sprite_buf[p+12] = y+8;
  gr_sprite_buf[p+13] = pat+17;
  gr_sprite_buf[p+14] = mode;
  gr_sprite_buf[p+15] = x+8;
  gr_sprite_idx += 16;
}

function pad_update():void
{
  PAD_CTRL = 1;
  PAD_CTRL = 0;
  pad_a = PAD_CTRL % 2;
  pad_b = PAD_CTRL % 2;
  pad_select = PAD_CTRL % 2;
  pad_start = PAD_CTRL % 2;
  pad_up = PAD_CTRL % 2;
  pad_down = PAD_CTRL % 2;
  pad_left = PAD_CTRL % 2;
  pad_right = PAD_CTRL % 2;
}

function wait(n:int):void
{
  while( n ){
    var i:int = 55;
    while( i ){
      var j:int = 255;
      while( j ){
        j -= 1;
      }
      i -= i;
    }
    n -= 1;
  }
}

var anim:int = 0;
var anim_wait:int = 0;

var my_x:int = 100;
var my_y:int = 100;
var my_wait:int;

const MY_BUL_MAX = 16;
var my_bul_x:int[MY_BUL_MAX];
var my_bul_y:int[MY_BUL_MAX];
var my_bul_idx:int = 0;

const EN_MAX = 16;
var en_type:int[EN_MAX];
var en_x:int[EN_MAX];
var en_y:int[EN_MAX];
var en_p1:int[EN_MAX];
var en_p2:int[EN_MAX];
var en_wait:int = 0;
var en_now = 0;

const SPR_MIKU = 0x80;
const SPR_NEGI = 0xa0;

function my_process():void
{
  // 自機の移動
  pad_update();
  if( pad_up ){ my_y -= 2; }
  if( pad_down ){ my_y += 2; }
  if( pad_left ){ my_x -= 2; }
  if( pad_right ){ my_x += 2; }

  if( my_wait == 0 ){
    if( pad_a ){
      my_bul_x[my_bul_idx] = my_x;
      my_bul_y[my_bul_idx] = my_y-8;
      my_bul_idx = ( my_bul_idx + 1 ) % MY_BUL_MAX;
      my_wait = 4;
    }
  }else{
    my_wait -= 1;
  }

  gr_sprite2x2( my_x-8, my_y-8, SPR_MIKU+anim*2, 0 );
    
}

function my_bul_process():void
{
  // 自機の弾の処理
  var i = 0;
  while( i<MY_BUL_MAX ){
    if( my_bul_y[i] ){
      if( my_bul_y[i] > 8 ){
        my_bul_y[i] -= 6;
        gr_sprite( my_bul_x[i]-4, my_bul_y[i]-4, SPR_NEGI+anim, 0 );
        gr_sprite( my_bul_x[i]-4, my_bul_y[i]+4, SPR_NEGI+anim+16, 0 );
      }else{
        my_bul_y[i] = 0;
      }
    }
    i += 1;
  }
}

function en_process(idx:int):void
{
  if( en_type[idx] ){
    en_y[idx] += 2;

    var i = 0;
    while( i < MY_BUL_MAX ){
      if( my_bul_y[i] != 0 && en_x[idx] + 8 - my_bul_x[i] < 16 && en_y[idx] + 8 - my_bul_y[i] < 16 ){
        en_type[idx] = 0;
        my_bul_y[i] = 0;
      }
      i += 1;
    }

    // 死亡判定
    if( en_y[idx] > 240 ){
      en_type[idx] = 0;
    }else{
      gr_sprite2x2( en_x[idx]-8, en_y[idx]-8, 0x56, 0 );
    }
  }
}

function main(): void
{
  const PAL:int[32] = [0x0f,0x19,0x29,0x30, 0x0f,0x11,0x12,0x13, 0x0f,0x11,0x12,0x13, 0x0f,0x11,0x12,0x13,
                       0x0f,0x19,0x29,0x30, 0x0f,0x11,0x12,0x13, 0x0f,0x11,0x12,0x13, 0x0f,0x11,0x12,0x13];

  ppu_lock();
  
  ppu_put( 0x3f00, PAL, 32 );
  
  ppu_unlock();

  gr_add( 0x2080, "FUGA", 4 );
  gr_add( 0x20A0, "PIYO", 5 );

  var x = 100, y = 100;
  
  while( 1 ){
    anim_wait += 1;
    anim = anim_wait / 8 % 4;
    
    my_process();
    my_bul_process();

    // 敵の出現
    if( en_wait == 0 ){
      en_type[en_now] = 1;
      en_x[en_now] = 100+en_now*16;
      en_y[en_now] = 0;
      en_now = (en_now+1)%EN_MAX;
      en_wait = 60;
    }else{
      en_wait -= 1;
    }
    
    var i = 0;
    while( i<EN_MAX ){
      en_process(i);
      i += 1;
    }
    wait_vsync();
  }
  
}

main();
