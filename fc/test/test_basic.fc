/*
include( "nes.fc" );
include( "nes.asm" );
include( "test/character.chr" );
*/

include( "emu.fc" );

var i1:int;
const CONST = 2;
var a1:int[4];
var a2:int[CONST];
const a3:int[] = [1,2];
const s1 = "hoge";

function test_const_op():void
{
	print('test_const_op:');
	assert_equal( 1, 1, 'num');
	assert_equal( (18%((2*((10+10)-5))/3)), 8, '+,-,*,/,%');
	assert_true(  (1 < 2), "<");
	assert_true( !(2 < 2), "!,<");
	assert_true(  (2 > 1), ">");
	assert_true( !(2 > 2), "!,>");
	assert_true(  (2 <= 2), "<=");
	assert_true( !(3 <= 2), "!,<=");
	assert_true(  (3 >= 2), ">=");
	assert_true( !(2 >= 3), "!,>=");
	assert_true( 2 == 2, "==");
	assert_true( 2 != 3, "!=");
	puts('');
}

function test_int_op():void
{
	print('test_int_op:');

	var i1 = 1;
	var i2 = 2;
	var i3 = 3;
	var i5 = 5;
	var i10 = 10;

	assert_equal( i1, i1, 'num');
	assert_equal( i2*i3, 6, '2*3');
	assert_equal( i5*i5, 25, '+,-,*,/,%');
	assert_equal( i5*60, 44, '+,-,*,/,%');
	assert_equal( i10/i3, 3, '/');
	assert_equal( 255/i10, 25, '/');
	assert_equal( 255%i10, 5, '%');
	assert_equal( (18%((i2*((i10+i10)-i5))/i3)), 8, '+,-,*,/,%');

	assert_equal( i3 & i2, 2, '&' );
	assert_equal( i1 | i2, 3, '|' );
	assert_equal( i3 ^ i2, 1, '^' );

	assert_true(  (i1 < i2), "<");
	assert_true( !(i2 < i2), "!,<");
	assert_true(  (i2 > i1), ">");
	assert_true( !(i2 > i2), "!,>");
	assert_true(  (i2 <= i2), "<=");
	assert_true( !(i3 <= i2), "!,<=");
	assert_true(  (i3 >= i2), ">=");
	assert_true( !(i2 >= i3), "!,>=");
	assert_true( i2 == i2, "==");
	assert_true( i2 != i3, "!=");

	// 定数の最適化
	assert_equal( i10*16, 160, '*const' );
	assert_equal( i10/4, 2, '/const' );
	assert_equal( i10%8, 2, '%const' );
  
	puts('');
}

function test_int8_op():void
{
	print('test_int8_op:');

	var i1:sint8 = -1;
	var i2:sint8 = -2;
	var i3:sint8 = 3;
	var m3:sint8 = -3;
	var i5:sint8  = -5;
	var i10:sint8 = 10;
	var m10:sint8 = -10;

	assert_equal( i1, i1, 'num');
	assert_equal( i10/i3, 3, '10/3');
	assert_equal( m10/i3, -4, '10/-3');
	assert_equal( i10/m3, -4, '-10/-3');
	assert_equal( m10/m3, 3, '-10/-3');
	//assert_equal( i10/i2, -5, '+,-,*,/,%');
	/*
	  assert_equal( i5*i5, 25, '+,-,*,/,%');
	  assert_equal( i5*60, 44, '+,-,*,/,%');
	  assert_equal( i10/i3, 3, '/');
	  assert_equal( 255/i10, 25, '/');
	  assert_equal( 255%i10, 5, '%');
	*/
	/*
	  assert_equal( (18%((i2*((i10+i10)-i5))/i3)), 8, '+,-,*,/,%');

	  assert_equal( i3 & i2, 2, '&' );
	  assert_equal( i1 | i2, 3, '|' );
	  assert_equal( i3 ^ i2, 1, '^' );
  
	  assert_true(  (i1 < i2), "<");
	  assert_true( !(i2 < i2), "!,<");
	  assert_true(  (i2 > i1), ">");
	  assert_true( !(i2 > i2), "!,>");
	  assert_true(  (i2 <= i2), "<=");
	  assert_true( !(i3 <= i2), "!,<=");
	  assert_true(  (i3 >= i2), ">=");
	  assert_true( !(i2 >= i3), "!,>=");
	  assert_true( i2 == i2, "==");
	  assert_true( i2 != i3, "!=");

	  // 定数の最適化
	  assert_equal( i10*16, 160, '*const' );
	  assert_equal( i10/4, 2, '/const' );
	  assert_equal( i10%8, 2, '%const' );
	*/
  
	puts('');
}

function test_int16_op():void
{
	print('test_int16_op:');

	var i1:int16 = 1;
	var i2:int16 = 2;
	var i3:int16 = 3;
	var i5:int16 = 5;
	var i10:int16 = 10;

	assert_equal( i1, i1, 'num');
	//assert_equal( i2*((i10+i10)-i5), 30, '+,-,*,/,%');
	//assert_equal( (18%((2*((i10+10)-5))/3)), 8, '+,-,*,/,%');

	assert_equal( i3 & i2, 2, '&' );
	assert_equal( i1 | i2, 3, '|' );
	assert_equal( i3 ^ i2, 1, '^' );
  
	assert_true(  (i1 < i2), "<");
	assert_true( !(i2 < i2), "!,<");
	assert_true(  (i2 > i1), ">");
	assert_true( !(i2 > i2), "!,>");
	assert_true(  (i2 <= i2), "<=");
	assert_true( !(i3 <= i2), "!,<=");
	assert_true(  (i3 >= i2), ">=");
	assert_true( !(i2 >= i3), "!,>=");
	assert_true( i2 == i2, "==");
	assert_true( i2 != i3, "!=");

	// 定数の最適化
	assert_equal( i10*16, 160, '*const' );
	assert_equal( i10/4, 2, '/const' );
	assert_equal( i10%8, 2, '%const' );
  
	puts('');
}

function test_int8x16_op():void
{
	/*
	print('test_int8x16_op:');

	var i1:int = 1;
	var i2:int = 2;
	var i3:int = 3;
	var i10:int16 = 10;
	var w1:int16 = 1;
	var w2:int16 = 2;
	var w3:int16 = 3;
	var w10:int16 = 10;

	assert_equal( w1, i1, 'num');
	assert_equal( (18%((2*((10+10)-5))/3)), 8, '+,-,*,/,%');
	assert_true(  (w1 < i2), "<");
	assert_true( !(w2 < i2), "!,<");
	assert_true(  (w2 > i1), ">");
	assert_true( !(w2 > i2), "!,>");
	assert_true(  (w2 <= i2), "<=");
	assert_true( !(w3 <= i2), "!,<=");
	assert_true(  (w3 >= i2), ">=");
	assert_true( !(w2 >= i3), "!,>=");
	assert_true( w2 == i2, "==");
	assert_true( w2 != i3, "!=");
	puts('');
	*/
}

function test_logical_op():void
{
	print('test_logical_op:');
	
	var T = 1;
	var F = 0;
	assert_true(    T && T , "T&&T");
	assert_true(  !(T && F), "T&&F");
	assert_true(  !(F && T), "F&&T");
	assert_true(  !(F && F), "F&&F");
	assert_true(    T || F , "T||F");
	assert_true(    T || F , "T||F");
	assert_true(    F || T , "F||T");
	assert_true(  !(F || F), "F||F");
	puts('');
}

// NESの制限によるエラーをテスト、主にコンパイル時エラーになる
function test_nesasm_limit():void
{
	// 長い識別子がエラーになる( NESASMの１行制限のため )
	var toooooooooooooooooooooooooooooooooooooooo_long_id: int = 0;
	toooooooooooooooooooooooooooooooooooooooo_long_id = toooooooooooooooooooooooooooooooooooooooo_long_id + 1;
	// 長い文字列がエラーになる( NESASMの１行80文字制限のため )
	var i:int* = "toooooooooooooooooooooooooooooooooooooooooooooooooo_long_string";
}

function add(a:int, b:int):int
{
	return a+b;
}

function fib(n:int):int
{
	if( n <= 1 ){
		return 1;
	}else{
		return fib(n-1)+fib(n-2);
	}
}

function test_function():void
{
	print('test_function:');
	
	assert_equal( add(3,5), 8, "add()");
	
	assert_equal(  fib( 1),   1, "fib(1)");
	assert_equal(  fib( 3),   3, "fib(3)");
	assert_equal(  fib(11), 144, "fib(11)");
	puts('');
}

function main():void
{
	init();
	
	test_const_op();
	test_int_op();
	test_function();
	test_int8_op();
	test_int16_op();
	test_int8x16_op();
	test_logical_op();
	test_nesasm_limit();
	
	// print("hoge\nfuga");
	exit(0);

}
