#!/usr/bin/env ruby -Ku
# coding: utf-8

#
#
#

require 'pp'
require 'optparse'
require 'strscan'
require_relative 'parser'

def mangle(str)
  str.gsub(/\$|_/){|v| { '$'=>'_V', '_'=>'__' }[v] }
end

######################################################################
# パーサー
######################################################################
class Parser

  def initialize( src )
    @scanner = StringScanner.new(src)
    @line = 1
    @pos_info = Hash.new
  end

  def next_token
    # コメントと空白を飛ばす
    while @scanner.scan(/ \s+ | \/\/.+?\n | \/\*.+?\*\/ /mx)
      @scanner[0].gsub(/\n/){ @line += 1 }
    end
    if @scanner.eos?
      r = nil
    elsif @scanner.scan(/<=|>=|==|!=|\(|\)|\{|\}|;|:|<|>|\[|\]|\+|-|\*|\/|=|,|@|!/)
      # 記号
      r = [@scanner[0], @scanner[0]]
    elsif @scanner.scan(/0[xX](\d+)/)
      # 16進数
      r = [:NUMBER, @scanner[1].to_i(16)]
    elsif @scanner.scan(/0[bB](\d+)/)
      # 2進数
      r = [:NUMBER, @scanner[1].to_i(2)]
    elsif @scanner.scan(/\d+/)
      # 10進数
      r = [:NUMBER, @scanner[0].to_i]
    elsif @scanner.scan(/\w+/)
      # 識別子/キーワード
      if /function|const|var|options|if|else|while|return|break|continue|include_bin|int|uint|int8|uint8|int16|uint16/ === @scanner[0]
        r = [@scanner[0], @scanner[0]]
      else
        r = [:IDENT, @scanner[0].to_sym ]
      end
    elsif @scanner.scan(/"([^\\"]|\\.)*"/)
      # 文字列
      r = [:STRING, @scanner[0][1..-2]]
    else
      raise "invalid token at #{@line}"
    end
    # pp r
    r
  end

  def info( ast )
    @pos_info[ast] = @line
  end

  def parse
    ast = do_parse
    [ast, @pos_info]
  end
end

######################################################################
# 型
######################################################################
class TypeDecl

  attr_reader :type # 種類( :int, :pointer, :array のいずれか )
  attr_reader :size # サイズ[byte]
  attr_reader :length # 配列の要素数
  attr_reader :signed # signedかどうか(intの場合のみ)
  attr_reader :base # ベース型(pointerとarrayの場合のみ)

  def initialize( ast )
    if String === ast
      @type = :int
      case ast
      when 'int'
        @size = 1
        @signed = true
      when 'uint'
        @size = 1
        @signed = false
      end
    elsif Array === ast 
      if ast[0] == :pointer
        @type = :pointer
        @base = TypeDecl[ ast[1] ]
        @size = 2
      else Array === ast[0] and ast[0][0] == :array
        @type = :array
        @base = TypeDecl[ ast[1] ]
        @length = ast[0][1]
        @size = @base.size * @length
      end
    end

    case @type
    when :int
      @str = ast
    when :pointer
      @str = "#{@base}*"
    when :array
      @str = "#{@base}[#{@length}]"
    else
      raise "invalid type declaration #{ast}"
    end
  end

  def self.[]( ast )
    @@cache = Hash.new unless defined?(@@cache)
    type = TypeDecl.new( ast )
    @@cache[type.to_s] = type unless @@cache[type.to_s]
    @@cache[type.to_s]
  end

  def to_s
    @str
  end

end

######################################################################
# 値を持つもの(変数、テンポラリ変数、リテラル、定数など）
######################################################################
class Value
  attr_reader :kind # 種類( :var, :temp, :const, :literal のいずれか）
  attr_reader :id # 変数名( リテラルの場合は、nil )
  attr_reader :type # TypeDecl
  attr_reader :val # リテラルもしくは定数の場合は数値、変数の場合は初期化式のASTかnil
  attr_reader :opt # オプション
  attr_reader :scope # スコープ(Function)
  attr_reader :temp # テンポラリ変数かどうか

  def self.literal( val )
    Value.new( nil, TypeDecl["int"], val, nil, nil, :literal )
  end

  def initialize( id, type, val, opt, scope, kind=:var )
    raise "invalid type, #{type}" unless TypeDecl === type
    @id = id
    @type = type
    @val = val
    @opt = opt
    @scope = scope
    @kind = kind
  end

  def left_value?
    (@kind == :var)
  end

  def const?
    Numeric === @val
  end

  def to_s
    if @id
      if @scope
        "#{scope.id}$#{id}:#{type}"
      else
        "#{id}:#{type}"
      end
    else
      @val.inspect
    end
  end

end

# エラークラス
class CompileError < RuntimeError
  attr_accessor :line
  attr_accessor :file
end

######################################################################
# 関数
######################################################################
class Function
  attr_reader :id, :args, :vars, :ast, :ops, :special, :block
  def initialize( global, id, args, ast_or_block )
    @global = global
    @id = id
    @vars = Hash.new
    @arg_len = args.size
    @args = args.map {|v| new_var(*v) }
    if Proc === ast_or_block
      @special = true
      @block = ast_or_block
    else
      @special = false
      @ast = ast_or_block
    end
    @tmp_count = 0
    @label_count = 0
    @ops = []
    @loops = []
    @cur_line = 0
  end

  def compile( ast )
    begin
      compile_block( ast )
    rescue CompileError
      puts "hoge.fc:#{@cur_line}: #{$!}"
      raise
    rescue
      puts "hoge.fc:#{@cur_line}: error"
      raise
    end
  end

  def compile_block( block )
    block.each do |ast|
      compile_statement( ast )
    end
  end

  def compile_statement( ast )
    update_pos( ast )
    case ast[0]
    when :var
      ast[1].each do |v|
        new_var v[0], TypeDecl[v[1]], v[2], v[3]
      end
      nil

    when :'if'
      then_label, else_label, end_label = new_labels('then', 'else','end')
      cond = rval(ast[1])
      emit :if, cond, else_label
      emit :label, then_label
      compile_block(ast[2])
      emit :jump, end_label
      emit :label, else_label
      if ast[3]
        compile_block(ast[3])
        emit :label, end_label
      end
      nil

    when :'while'
      begin_label, end_label = new_labels('begin', 'end')
      @loops << end_label
      emit :label, begin_label
      cond = rval(ast[1])
      emit :if, cond, end_label
      compile_block ast[2]
      emit :jump, begin_label
      emit :label, end_label
      @loops.pop

    when :break
      raise CompileError.new("cannot break without loop") if @loops.empty?
      emit :jump, @loops[-1]

    when :return
      emit :return, rval(ast[1])

    when :exp
      pp ast[1]
      const_eval( ast[1] )
      rval( ast[1] )
      pp const_eval( ast[1] )

    else
      raise "unknow op #{ast}"
    end
  end

  def const_eval( ast )
    r = ast
    case ast
    when Symbol
      var = find_var( ast )
      r = var.val if var.const?
    when Numeric
      r = ast
    when String
      r = ast
      # TODO
    when Array
      case ast[0]
      when :add, :sub, :mul, :div, :eq, :ne, :lt, :gt, :le, :ge
        ast[1] = const_eval( ast[1] )
        ast[2] = const_eval( ast[2] )
        if Numeric === ast[1] and Numeric === ast[2]
          case ast[0]
          when :add then r = ast[1] +  ast[2]
          when :sub then r = ast[1] -  ast[2]
          when :mul then r = ast[1] *  ast[2]
          when :div then r = ast[1] /  ast[2]
          when :eq  then r = ast[1] == ast[2]
          when :ne  then r = ast[1] != ast[2]
          when :lt  then r = ast[1] <  ast[2]
          when :gt  then r = ast[1] >  ast[2]
          when :le  then r = ast[1] <= ast[2]
          when :ge  then r = ast[1] >= ast[2]
          end
        end
      when :not, :uminus
        ast[1] = const_eval( ast[1] )
        if Numeric === ast[1]
          case ast[0]
          when :not then r = ~ast[1]
          when :uminus then r = -ast[1]
          end
        end
      end
    end
    r
  end

  def rval( ast )
    case ast
    when Symbol
      r = find_var( ast )
    when Numeric
      r = Value.literal( ast )
    when String
      # TODO
    when Array
      case ast[0]
      when :load
        left = rval(ast[1])
        right = rval(ast[2])
        compatible_type( left.type, right.type )
        raise CompileError.new("#{left} is not left value") unless left.left_value?
        emit :load, left, right
        r = left
      when :not, :uminus
        left = rval(ast[1])
        r = new_tmp( left.type )
        emit ast[0], r, left
      when :add, :sub, :mul, :div
        left = rval(ast[1])
        right = rval(ast[2])
        r = new_tmp( compatible_type( left.type, right.type ) )
        emit ast[0], r, left, right
      when :eq, :lt
        left = rval(ast[1])
        right = rval(ast[2])
        compatible_type( left.type, right.type )
        r = new_tmp( TypeDecl["int"] )
        emit ast[0], r, left, right
      when :ne, :gt, :le, :ge
        left = ast[1]
        right = ast[2]
        case ast[0]
        when :ne
          r = rval([:not, [:eq, left, right]])
        when :gt
          r = rval([:lt, right, left])
        when :le
          r = rval([:not, [:lt, right, left]])
        when :ge
          r = rval([:not, [:lt, left, right]])
        end
      when :call
        func = @global.find_func( ast[1] )
        if func.special
          func.block.call self, *ast[2]
        else
          ast[2].each_with_index do |arg,i|
            emit :load, func.args[i], rval(arg)
          end
          emit :call, func
        end
      else
        raise "unknown op #{ast}"
      end
    else
      raise "unknown op #{ast}"
    end
    r
  end

  def compatible_type( a, b )
    return a if  a == b
    if a.type == :int and b.type == :int
      if a.size > b.size then return a else return b end
    end
    raise "cant convert type #{a} and #{b}"
  end

  def update_pos( ast )
    if @global.pos_info[ast]
      @cur_line = @global.pos_info[ast]
      puts "compling ... line #{@cur_line}"
    end
  end

  def emit( *op )
    @ops << op
  end

  def new_label( name )
    new_labels( [name] )[0]
  end

  def new_labels( *names )
    @label_count += 1
    names.map { |n| '.'+n+'_'+@label_count.to_s }
  end

  def new_tmp( type )
    var = new_var("#{@tmp_count}".intern, type, nil, nil, true )
    @tmp_count += 1
    var
  end

  def new_var(id,type,init,opt,temp=false)
    raise CompileError.new("var #{id} already defined") if @vars[id]
    var = Value.new(id,type,init,opt,self, temp ? :temp : :var )
    @vars[id] = var
    var
  end

  def find_var(id)
    if @vars[id]
      @vars[id]
    elsif @global.vars[id]
      @global.vars[id]
    else
      raise "var #{id} not defined"
    end
  end

  def to_s
    "<Function:#{id}>"
  end

end

######################################################################
# コンパイラ
######################################################################
class Compiler
  attr_reader :ast, :func ,:vars, :options, :include_bin, :pos_info

  def initialize
    @vars = Hash.new
    @func = Hash.new
    @options = Hash.new
    @include_bin = []
    @pos_info = nil
  end

  def compile( src )
    ast, @pos_info = Parser.new(src).parse
    pp ast

    ast.each do |e|
      case e[0] 
      when :function
        @func[e[1]] = Function.new( self, *e[1..-1] )
      when :const
        e[1].each do |v|
          raise "const without value #{v}" unless v[2]
          @vars[v[0]] = Value.new( v[0], TypeDecl[v[1]], v[2], v[3], nil )
        end
        @vars[e[1]] = var
      when :var
        e[1].each do |v|
          @vars[v[0]] = Value.new( v[0], TypeDecl[v[1]], v[2], v[3], nil )
        end
      when :options
        @options.merge!( e[1] )
      when :include_bin
        @include_bin << e[1]
        if e[1][:name]
          var = Value.new( e[1][:name] )
          var.include_bin = true
          @vars[e[1]] = var
        end
      else
        raise
      end
    end

    # interruptがない場合は、追加する
    unless @func[:interrupt]
      @func[:interrupt] = Function.new( self, :interrupt, [], [] )
    end

    # アセンブラコードの出力
    opt_asm = []
    inc_asm = []
    var_asm = []
    func_asm = []

    opt_asm << "; options"
    @options.each do |opt,val|
      if [:inesprg, :ineschr, :inesmir, :inesmap].include?(opt)
        opt_asm << "    .#{opt} #{val};"
      end
    end

    inc_asm << '; include_bin'
    @include_bin.each do |inc|
      if inc[:bank]
        inc_asm << "    .bank #{inc[:bank]}"
        inc_asm << "    .org #{inc[:address] or 0}" 
        inc_asm << "    .incbin \"#{inc[:file]}\""
      else
        func_asm << "#{inc[:name]}: .incbin \"#{inc[:file]}\""
      end
    end

    var_asm << "; global"
    @vars.each do |id,v|
      #if v.include_bin or v.val
        # DO NOTHING
      #elsif v.address
        # var_asm << "#{v.to_asm} = $#{'%4x'%[v.address]}"
      #else
        # var_asm << "#{v.to_asm} .ds 1"
      #end
    end

    @func.each do |id,f|
      next unless f.ast
      func_asm << "; function #{id}"
      func_asm << "#{id}:"

      f.compile( f.ast )

      var_asm << "; function #{id}"
      # func_asm.concat OpCompiler.compile( f.ops )
      func_asm << "    rts"

      f.vars.each do |id,v|
        if v.val
          # func_asm << "#{v.to_asm} .db \"#{v.val}\",0"
        else
          # var_asm << "#{v.to_asm} .ds 1"
        end
      end
    end

    @func.each do |id,f|
      puts 
      pp f
      pp f.args
      pp f.vars
    end

  end

  def find_func( id )
    raise "function #{id} not found " unless @func[id]
    @func[id]
  end

end

if __FILE__ == $0
  $out = 'a.asm'
  opt = OptionParser.new( "NES Compiler\nUsage: fc [options] <src.fc> ...\nOptions:\n" )
  opt.on( '-h', '--help' ){ puts opt; exit }
  opt.on( '-o', 'output file' ){|v| $out = v }
  opt.on( '-S', 'output asm file' ){|v| $asm = true }
  opt.on( '-d', '--debug', 'show debug info' ){|v| $debug_info = true }
  opt.parse!

  asm_file = ARGV[0].sub(/\..+$/){'.asm'}
  src = ARGF.read
    
  @com = Compiler.new

  asm = @com.compile( src )

  if $debug_info
    pp @com
    @com.func.each { |id,f| puts f; pp f.ops }
  end

  open(asm_file,'w'){|f| f.write asm }

  unless $asm
    # system( 'nesasm', $out, asm_file )
  end

end

