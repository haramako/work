#!/usr/bin/env ruby -Ku
# coding: utf-8

#
#
#

require 'pp'
require 'optparse'
require_relative 'parser'

def mangle(str)
  str.gsub(/\$|_/){|v| { '$'=>'_V', '_'=>'__' }[v] }
end

class FcParser
  def initialize( src )
    @pos = 0
    @src = src
  end

  def next_token
    next_token2# .tap{|v| p v }
  end

  def next_token2
    @pos+=1 while /\s/ === @src[@pos]
    return [false,false] if @pos >= @src.size

    c = @src[@pos]
    case c
    when /\//
      # コメント、もしくは '/'
      if @src[@pos+1] == '/'
        mo = @src.match( /\/\/.+/, @pos )
        @pos += mo[0].length
        return next_token
      elsif @src[@pos+1] == '*'
        mo = @src.match( /\/\*.+?\*\//m, @pos )
        @pos += mo[0].length
        return next_token
      else
        @pos += 1
        return [c,c]
      end
    when /\(|\)|\{|\}|;|:|<|>|\+|-|=|,|@|!/ 
      # 記号
      mo = @src.match( /<=|>=|==|!=|\(|\)|\{|\}|;|:|<|>|\+|-|=|,|@|!/, @pos )
      @pos += mo[0].length
      return [mo[0],mo[0]]
    when /\d/
      # 数字
      if @src[@pos,2] == '0x' and mo = @src.match( /0x[0-9a-zA-Z]+/, @pos )
        @pos += mo[0].length
        return [:NUMBER, mo[0].to_i(16) ]
      elsif @src[@pos,2] == '0b' and mo = @src.match( /0b[01]+/, @pos )
        @pos += mo[0].length
        return [:NUMBER, mo[0].to_i(2) ]
      else
        mo = @src.match( /\d+/, @pos )
        @pos += mo[0].length
        return [:NUMBER, mo[0].to_i ]
      end
    when /[a-zA-Z]/ 
      # 識別子/キーワード
      mo = @src.match( /[a-zA-Z0-9_]+/, @pos )
      @pos += mo[0].length
      # キーワードかどうかを判別する
      if /function|const|var|options|if|else|while|return|break|continue|include_bin/ === mo[0]
        return [mo[0], mo[0]]
      else
        return [:IDENT, mo[0].to_sym ]
      end
    when /"/
      # 文字列
      mo = @src.match( /"([^"]+)"/, @pos )
      @pos += mo[0].length
      return [:STRING, mo[1] ]
    else
      raise "invalid character #{c}"
    end
  end

  def self.parse( src )
    parser = FcParser.new( src )
    parser.do_parse
  end
end

class Variable
  attr_reader :id, :function
  attr_accessor :val, :address, :include_bin
  def initialize( id, function = nil )
    @id = id
    @function = function
  end
  def to_asm
    if Numeric === val
      '#'+val.to_s
    else
      mangle(to_s)
    end
  end
  def to_s
    if function
      "#{function.id}$#{id}"
    else
      "#{id}"
    end
  end
end

class Function
  attr_reader :id, :args, :vars, :ast, :ops, :special, :block
  def initialize( global, id, args, ast_or_block )
    @global = global
    @id = id
    @vars = Hash.new
    @arg_len = args.size
    @args = args.map {|v| new_var(v) }
    if Proc === ast_or_block
      @special = true
      @block = ast_or_block
    else
      @special = false
      @ast = ast_or_block
    end
    @tmp_count = 0
    @label_count = 0
    @ops = []
    @loops = []
  end

  def compile_block( block )
    block.each do |ast|
      exp( ast )
    end
  end

  def exp( ast )
    case ast
    when Array 
      case ast[0]
      when :var
        ast[1].each do |v|
          new_var v
        end
        nil
      when :'if'
        then_label, else_label, end_label = new_labels('then', 'else','end')
        cond = exp(ast[1])
        emit :if, cond, else_label
        emit :label, then_label
        compile_block(ast[2])
        emit :jump, end_label
        emit :label, else_label
        if ast[3]
          compile_block(ast[3])
          emit :label, end_label
        end
        nil
      when :'while'
        begin_label, end_label = new_labels('begin', 'end')
        @loops << end_label
        emit :label, begin_label
        cond = exp(ast[1])
        emit :if, cond, end_label
        compile_block ast[2]
        emit :jump, begin_label
        emit :label, end_label
        @loops.pop
      when :break
        raise "cannot break without loop" if @loops.empty?
        emit :jump, @loops[-1]
      when :return
        emit :return, exp(ast[1])
      when :call
        func = @global.find_func( ast[1] )
        if func.special
          func.block.call self, *ast[2]
        else
          ast[2].each_with_index do |arg,i|
            emit :load, func.args[i], exp(arg)
          end
          emit :call, func
        end
      when :put
        emit :load, exp(ast[1]), exp(ast[2])
        ast[1]
      when :not, :uminus
        r = new_tmp
        left = exp(ast[1])
        emit ast[0], r, left
        r
      when :add, :sub, :mul, :div, :ne, :lt
        r = new_tmp
        left = exp(ast[1])
        right = exp(ast[2])
        emit ast[0], r, left, right
        r
      when :eq
        exp([:not, [:ne, ast[1], ast[2]]])
      else
        raise "unknow op #{ast}"
      end
    when Symbol
      find_var ast
    when Numeric
      ast
    when String
      var = new_tmp
      var.val = ast
      var
    else
      raise "invalid ast #{ast}"
    end
  end

  def emit( *op )
    @ops << op
  end

  def new_label( name )
    @label_count += 1
    '.'+name+'_'+@label_count.to_s
  end

  def new_labels( *names )
    @label_count += 1
    names.map { |n| '.'+n+'_'+@label_count.to_s }
  end

  def new_tmp
    var = new_var("#{@tmp_count}".intern)
    @tmp_count += 1
    var
  end

  def new_var(id)
    raise "var #{id} already defined" if @vars[id]
    var = Variable.new(id,self)
    @vars[id] = var
    var
  end

  def find_var(id)
    if @vars[id]
      @vars[id]
    elsif @global.vars[id]
      @global.vars[id]
    else
      raise "var #{id} not defined"
    end
  end

  def to_s
    "<Function:#{id}>"
  end

  def to_asm
    id.to_s
  end

end

module OpCompiler
  module_function

  def to_asm( op )
    if op.respond_to?(:to_asm)
      op.to_asm
    elsif Numeric === op
      "#"+op.to_s
    else
      op.to_s
    end
  end

  def compile( ops )
    r = []
    ops.each do |op|
      r << "; #{op.inspect}"
      case op[0]
      when :label
        r << op[1] + ':'
      when :if
        r << "lda #{to_asm(op[1])}"
        r << "beq #{to_asm(op[2])}"
      when :jump
        r << "jmp #{to_asm(op[1])}"
      when :return
        r << "lda #{to_asm(op[1])}"
        r << "rts"
      when :call
        r << "jsr #{to_asm(op[1])}"
      when :load
        r << "lda #{to_asm(op[2])}"
        r << "sta #{to_asm(op[1])}"
      when :add
        r << "lda #{to_asm(op[2])}"
        r << "clc"
        r << "adc #{to_asm(op[3])}"
        r << "sta #{to_asm(op[1])}"
      when :sub
        r << "lda #{to_asm(op[2])}"
        r << "sec"
        r << "sbc #{to_asm(op[3])}"
        r << "sta #{to_asm(op[1])}"
      when :ne
        r << "lda #{to_asm(op[2])}"
        r << "sec"
        r << "sbc #{to_asm(op[3])}"
        r << "eor #255"
        r << "sta #{to_asm(op[1])}"
      when :not
        r << "lda #{to_asm(op[2])}"
        r << "eor #255"
        r << "sta #{to_asm(op[1])}"
      when :asm
        op[1].each do |line|
          r << "#{line[0]} " + line[1..-1].map{|o|to_asm(o)}.join(",")
        end
      else
        raise "unknow op #{op}"
      end
    end
    # ラベル行以外はインデントする
    r = r.map do |line|
      if line.index(':') and line[0] != ';'
        line
      else
        "    "+line
      end
    end
    r
  end
end

class Compiler
  attr_reader :ast, :func ,:vars, :options, :include_bin

  def initialize
    @vars = Hash.new
    @func = Hash.new
    @options = Hash.new
    @include_bin = []

    add_func :ppu_put, [:addr,:size] do |f,addr,size|
      raise "addr must be symbol, but #{addr}" unless Symbol === addr
      raise "size must be number, but #{size}" unless Numeric === size
      f.emit :asm, [ [:lda, "#LOW(#{addr})"],
                     [:sta, "__reg+0"],
                     [:lda, "#HIGH(#{addr})"],
                     [:sta, "__reg+1"],
                     [:lda, f.exp(size)],
                     [:sta, "__reg+2"],
                     [:jsr, "__ppu_put"]]
      nil
    end

    add_func :ppu_fill, [:data,:size] do |f,data,size|
      raise "data must be number or variable, but #{data}" unless Variable === data or Numeric === data
      raise "size must be number, but #{size}" unless Numeric === size
      f.emit :asm, [ [:lda, f.exp(data)],
                     [:sta, "__reg+0"],
                     [:lda, f.exp(size)],
                     [:sta, "__reg+1"],
                     [:jsr, "__ppu_fill"]]
      nil
    end

    add_func :asm, [:asm] do |f,asm|
      raise "asm must be string, but #{asm}" unless String === asm
      f.emit :asm, [asm]
    end

    add_func :print, [:str] do |f,str|
      raise "asm must be string, but #{asm}" unless String === asm
      f.emit :asm, [asm]
    end
  end

  def add_func( id, args, &block )
    @func[id] = Function.new( self, id, args, block )
  end
    

  def compile( src )
    ast = FcParser.parse( src )
    ast.each do |e|
      case e[0] 
      when :function
        @func[e[1]] = Function.new( self, *e[1..-1] )
      when :const
        var = Variable.new( e[1] )
        var.val = e[2]
        @vars[e[1]] = var
      when :var
        var = Variable.new( e[1] )
        var.address = e[2] if e[2]
        @vars[e[1]] = var
      when :options
        @options.merge!( e[1] )
      when :include_bin
        @include_bin << e[1]
        if e[1][:name]
          var = Variable.new( e[1][:name] )
          var.include_bin = true
          @vars[e[1]] = var
        end
      else
        raise
      end
    end

    # interruptがない場合は、追加する
    unless @func[:interrupt]
      @func[:interrupt] = Function.new( self, :interrupt, [], [] )
    end

    # アセンブラコードの出力
    opt_asm = []
    inc_asm = []
    var_asm = []
    func_asm = []

    opt_asm << "; options"
    @options.each do |opt,val|
      if [:inesprg, :ineschr, :inesmir, :inesmap].include?(opt)
        opt_asm << "    .#{opt} #{val};"
      end
    end

    inc_asm << '; include_bin'
    @include_bin.each do |inc|
      if inc[:bank]
        inc_asm << "    .bank #{inc[:bank]}"
        inc_asm << "    .org #{inc[:address] or 0}" 
        inc_asm << "    .incbin \"#{inc[:file]}\""
      else
        func_asm << "#{inc[:name]}: .incbin \"#{inc[:file]}\""
      end
    end

    var_asm << "; global"
    @vars.each do |id,v|
      if v.include_bin or v.val
        # DO NOTHING
      elsif v.address
        var_asm << "#{v.to_asm} = $#{'%4x'%[v.address]}"
      else
        var_asm << "#{v.to_asm} .ds 1"
      end
    end

    @func.each do |id,f|
      next unless f.ast
      func_asm << "; function #{id}"
      func_asm << "#{id}:"

      f.compile_block( f.ast )

      var_asm << "; function #{id}"
      func_asm.concat OpCompiler.compile( f.ops )
      func_asm << "    rts"

      f.vars.each do |id,v|
        if v.val
          func_asm << "#{v.to_asm} .db \"#{v.val}\",0"
        else
          var_asm << "#{v.to_asm} .ds 1"
        end
      end
    end

    template = Compiler.templates['base.asm']
    asm = template
      .gsub('@OPTIONS'){opt_asm.join("\n")}
      .gsub('@INCLUDES'){inc_asm.join("\n")}
      .gsub('@VARS'){var_asm.join("\n")}
      .gsub('@FUNCS'){func_asm.join("\n")}
    asm
  end

  def find_func( id )
    raise "function #{id} not found " unless @func[id]
    @func[id]
  end

  def self.templates
    @@templates
  end

  @@templates = Hash.new
  DATA.read.split(/^@@/m)[1..-1].each do |tmpl|
    name, body = tmpl.split(/\n/,2)
    @@templates[name] = body
  end
      
end

if __FILE__ == $0
  $out = 'a.asm'
  opt = OptionParser.new( "NES Compiler\nUsage: fc [options] <src.fc> ...\nOptions:\n" )
  opt.on( '-h', '--help' ){ puts opt; exit }
  opt.on( '-o', 'output file' ){|v| $out = v }
  opt.on( '-S', 'output asm file' ){|v| $asm = true }
  opt.on( '-d', '--debug', 'show debug info' ){|v| $debug_info = true }
  opt.parse!

  asm_file = ARGV[0].sub(/\..+$/){'.asm'}
  src = ARGF.read
    
  @com = Compiler.new
  asm = @com.compile( src )

  if $debug_info
    pp @com
    @com.func.each { |id,f| puts f; pp f.args; pp f.vars; pp f.ast; pp f.ops }
  end

  open(asm_file,'w'){|f| f.write asm }

  unless $asm
    system( 'nesasm', $out, asm_file )
  end

end

__END__
@@base.asm
@OPTIONS
@INCLUDES
	.bank 1
	.org $FFFA
	.dw __interrupt
	.dw __start
	.dw 0

	.bank 0
	.org $0000
__reg: .ds 8
__putc_pos: .ds 1

	.org $0200
@VARS

	.org $8000
__start:
	sei
	ldx #0
	txs
	jsr main
.loop:
    jmp .loop

__interrupt:
    pha
    txa
    pha
    tya
    pha
    jsr interrupt
    pla
    tay
    pla
    tax
    pla
    rti

__ppu_put:
    ldy #0
.loop:
    lda [__reg+0],y
    sta $2007
    iny
    cpy __reg+2
    bne .loop
    rts

__ppu_fill:
    ldx #0
.loop:
    lda __reg+0
    sta $2007
    inx
    cpx __reg+1
    bne .loop
    rts

__putc:
    sta $70,x
    inx
    rts

@FUNCS
