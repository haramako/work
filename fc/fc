#!/usr/bin/env ruby -Ku
# coding: utf-8

#
#
#

require 'pp'
require 'optparse'
require 'strscan'
require_relative 'parser'

######################################################################
# パーサー
######################################################################
class Parser

  def initialize( src )
    @scanner = StringScanner.new(src)
    @line = 1
    @pos_info = Hash.new
  end

  def next_token
    # コメントと空白を飛ばす
    while @scanner.scan(/ \s+ | \/\/.+?\n | \/\*.+?\*\/ /mx)
      @scanner[0].gsub(/\n/){ @line += 1 }
    end
    if @scanner.eos?
      r = nil
    elsif @scanner.scan(/<=|>=|==|!=|\(|\)|\{|\}|;|:|<|>|\[|\]|\+|-|\*|\/|=|,|@|!/)
      # 記号
      r = [@scanner[0], @scanner[0]]
    elsif @scanner.scan(/0[xX](\d+)/)
      # 16進数
      r = [:NUMBER, @scanner[1].to_i(16)]
    elsif @scanner.scan(/0[bB](\d+)/)
      # 2進数
      r = [:NUMBER, @scanner[1].to_i(2)]
    elsif @scanner.scan(/\d+/)
      # 10進数
      r = [:NUMBER, @scanner[0].to_i]
    elsif @scanner.scan(/\w+/)
      # 識別子/キーワード
      if /^(function|const|var|options|if|else|while|return|break|continue|include_bin)$/ === @scanner[0]
        r = [@scanner[0], @scanner[0]]
      else
        r = [:IDENT, @scanner[0].to_sym ]
      end
    elsif @scanner.scan(/"([^\\"]|\\.)*"/)
      # 文字列
      r = [:STRING, @scanner[0][1..-2]]
    else
      raise "invalid token at #{@line}"
    end
    # pp r
    r
  end

  def info( ast )
    @pos_info[ast] = @line
  end

  def parse
    ast = do_parse
    [ast, @pos_info]
  end
end

######################################################################
# 型
######################################################################
class TypeDecl

  attr_reader :type # 種類( :int, :pointer, :array のいずれか )
  attr_reader :size # サイズ[byte]
  attr_reader :length # 配列の要素数
  attr_reader :signed # signedかどうか(intの場合のみ)
  attr_reader :base # ベース型(pointerとarrayの場合のみ)

  BASIC_TYPES = { int:[1,true], uint:[1,false], int8:[1,true], uint8:[1,false], int16:[2,true], uint16:[2,false] }

  def initialize( ast )
    if Symbol === ast
      @type = :int
      if BASIC_TYPES[ast]
        @size = BASIC_TYPES[ast][0]
        @signed = BASIC_TYPES[ast][1]
      else
        raise
      end
    elsif Array === ast 
      if ast[0] == :pointer
        @type = :pointer
        @base = TypeDecl[ ast[1] ]
        @size = 2
      else Array === ast[0] and ast[0][0] == :array
        @type = :array
        @base = TypeDecl[ ast[1] ]
        @length = ast[0][1]
        @size = @base.size * @length
        raise
      end
    end

    case @type
    when :int
      @str = "#{ast}"
    when :pointer
      @str = "#{@base}*"
    when :array
      @str = "#{@base}[#{@length}]"
    else
      raise "invalid type declaration #{ast}"
    end
  end

  def to_s
    @str
  end

  def self.[]( ast_or_type )
    return ast_or_type if TypeDecl === ast_or_type
    @@cache = Hash.new unless defined?(@@cache)
    type = TypeDecl.new( ast_or_type )
    @@cache[type.to_s] = type unless @@cache[type.to_s]
    @@cache[type.to_s]
  end

end

######################################################################
# 値を持つもの(変数、テンポラリ変数、リテラル、定数など）
######################################################################
class Value
  attr_reader :kind # 種類( :var, :temp, :const, :literal のいずれか）
  attr_reader :id # 変数名( リテラルの場合は、nil )
  attr_reader :type # TypeDecl
  attr_reader :val # リテラルもしくは定数の場合は数値、変数の場合は初期化式のASTかnil
  attr_reader :opt # オプション
  attr_reader :scope # スコープ(Function)
  attr_reader :temp # テンポラリ変数かどうか

  def self.literal( val )
    Value.new( nil, TypeDecl[:int], val, nil, nil, :literal )
  end

  def initialize( id, type, val, opt, scope, kind=:var )
    raise "invalid type, #{type}" unless TypeDecl === type
    @id = id
    @type = type
    @val = val
    @opt = opt
    @scope = scope
    @kind = kind
  end

  def assignable?
    ( @kind == :var or @type.type == :pointer )
  end

  def const?
    ( @kind == :literal or @kind == :const )
  end

  def to_s
    if @id
      if @scope
        "#{scope.id}$#{id}:#{type}"
      else
        "#{id}:#{type}"
      end
    else
      @val.inspect
    end
  end

end

# エラークラス
class CompileError < RuntimeError
  attr_accessor :line
  attr_accessor :file
end

######################################################################
# 関数
######################################################################
class Function
  attr_reader :id, :args, :ast, :type, :block
  def initialize( compiler, id, args, type, ast )
    @compiler = compiler
    @id = id
    @type = TypeDecl[type]
    @arg_len = args.size
    @block = ScopedBlock.new( compiler, compiler.block, id, ast )
    @args = args.map do |v| 
      @block.add_var Value.new(v[0],TypeDecl[v[1]],v[2],v[3],@block,:var) 
    end
    @block.new_tmp( @type ) # 返り値の変数
  end

  def to_s
    "<Function:#{@id}>"
  end
end

######################################################################
# スコープ月ブロック
######################################################################
class ScopedBlock
  attr_reader :base, :id, :ast, :vars, :ops

  def initialize( compiler, base, id, ast )
    @compiler = compiler
    @base = base
    @id = id
    @ast = ast
    @vars = Hash.new
    @tmp_count = 0
    @label_count = 0
    @ops = []
    @loops = []
    @cur_line = 0
  end

  def compile
    begin
      compile_block( @ast )
    rescue CompileError
      puts "hoge.fc:#{@cur_line}: #{$!}"
      raise
    end
  end

  def compile_block( block )
    block.each do |ast|
      compile_statement( ast )
    end
  end

  def compile_statement( ast )
    update_pos( ast )
    case ast[0]
    when :var
      ast[1].each do |v|
        add_var Value.new( v[0], TypeDecl[v[1]], v[2], v[3], self, :var )
      end
      nil

    when :const
      ast[1].each do |v|
        raise CompileError.new("connot define const without value #{v[0]}") unless v[2]
        v[2] = const_eval( v[2] )
        add_var Value.new( v[0], TypeDecl[v[1]], v[2], v[3], self, :const )
      end
      nil

    when :'if'
      then_label, else_label, end_label = new_labels('then', 'else','end')
      cond = rval(ast[1])
      emit :if, cond, else_label
      emit :label, then_label
      compile_block(ast[2])
      emit :jump, end_label
      emit :label, else_label
      if ast[3]
        compile_block(ast[3])
        emit :label, end_label
      end
      nil

    when :'while'
      begin_label, end_label = new_labels('begin', 'end')
      @loops << end_label
      emit :label, begin_label
      cond = rval(ast[1])
      emit :if, cond, end_label
      compile_block ast[2]
      emit :jump, begin_label
      emit :label, end_label
      @loops.pop

    when :break
      raise CompileError.new("cannot break without loop") if @loops.empty?
      emit :jump, @loops[-1]

    when :return
      emit :return, rval(ast[1])

    when :exp
      const_eval( ast[1] )
      rval( ast[1] )

    else
      raise "unknow op #{ast}"
    end
  end

  def rval( ast )
    v, left = lval( ast )
    if left
      r = new_tmp( v.type.base )
      emit :pget, r, v
      r
    else
      v
    end
  end

  def lval( ast )
    left_value = false
    case ast
    when Symbol
      r = find_var( ast )
    when Numeric
      r = Value.literal( ast )
    when String
      # TODO
    when Array
      case ast[0]
      when :load
        left, left_value = lval(ast[1])
        right = rval(ast[2])
        if left_value
          compatible_type( left.type.base, right.type )
          raise CompileError.new("#{left} is not left value") unless left.assignable?
          emit :pset, left, right
          r = left
          left_value = true
        else
          compatible_type( left.type, right.type )
          raise CompileError.new("#{left} is not left value") unless left.assignable?
          emit :load, left, right
          r = left
        end
      when :not, :uminus
        left = rval(ast[1])
        r = new_tmp( left.type )
        emit ast[0], r, left
      when :add, :sub, :mul, :div
        left = rval(ast[1])
        right = rval(ast[2])
        r = new_tmp( compatible_type( left.type, right.type ) )
        emit ast[0], r, left, right
      when :eq, :lt
        left = rval(ast[1])
        right = rval(ast[2])
        compatible_type( left.type, right.type )
        r = new_tmp( TypeDecl[:int] )
        emit ast[0], r, left, right
      when :ne, :gt, :le, :ge
        # これらは、eq,lt の引数の順番とnotを組合せて合成する
        left = ast[1]
        right = ast[2]
        case ast[0]
        when :ne
          r = rval([:not, [:eq, left, right]])
        when :gt
          r = rval([:lt, right, left])
        when :le
          r = rval([:not, [:lt, right, left]])
        when :ge
          r = rval([:not, [:lt, left, right]])
        end
      when :call
        func = @compiler.find_func( ast[1] )
        r = new_tmp( func.type )
        ast[2].each_with_index do |arg,i|
          emit :load, func.args[i], rval(arg)
        end
        emit :call, r, func
      when :index
        left = rval(ast[1])
        right = rval(ast[2])
        raise CompileError.new("index must be pointer or array") unless left.type.type == :pointer or left.type.type == :array
        raise CompileError.new("index must be int") if right.type.type != :int
        r = new_tmp( TypeDecl[[:pointer, left.type.base]] )
        emit :index, r, left, right
        left_value = true
      else
        raise "unknown op #{ast}"
      end
    else
      raise "unknown op #{ast}"
    end
    [r,left_value]
  end

  def const_eval( ast )
    r = ast
    case ast
    when Symbol
      var = find_var( ast )
      r = var.val if var.const?
    when Numeric
      r = ast
    when String
      r = ast
      # TODO
    when Array
      case ast[0]
      when :add, :sub, :mul, :div, :eq, :ne, :lt, :gt, :le, :ge
        ast[1] = const_eval( ast[1] )
        ast[2] = const_eval( ast[2] )
        if Numeric === ast[1] and Numeric === ast[2]
          case ast[0]
          when :add then r = ast[1] +  ast[2]
          when :sub then r = ast[1] -  ast[2]
          when :mul then r = ast[1] *  ast[2]
          when :div then r = ast[1] /  ast[2]
          when :eq  then r = ast[1] == ast[2]
          when :ne  then r = ast[1] != ast[2]
          when :lt  then r = ast[1] <  ast[2]
          when :gt  then r = ast[1] >  ast[2]
          when :le  then r = ast[1] <= ast[2]
          when :ge  then r = ast[1] >= ast[2]
          end
        end
      when :not, :uminus
        ast[1] = const_eval( ast[1] )
        if Numeric === ast[1]
          case ast[0]
          when :not then r = ~ast[1]
          when :uminus then r = -ast[1]
          end
        end
      end
    end
    r
  end

  def compatible_type( a, b )
    return a if  a == b
    if a.type == :int and b.type == :int
      if a.size > b.size then return a else return b end
    end
    raise "cant convert type #{a} and #{b}"
  end

  def update_pos( ast )
    if @compiler.pos_info[ast]
      @cur_line = @compiler.pos_info[ast]
      puts "compling ... line #{@cur_line}"
    end
  end

  def emit( *op )
    @ops << op
  end

  def new_label( name )
    new_labels( [name] )[0]
  end

  def new_labels( *names )
    @label_count += 1
    names.map { |n| '.'+n+'_'+@label_count.to_s }
  end

  def new_tmp( type )
    var = new_var("#{@tmp_count}".intern, type, nil, nil, true )
    @tmp_count += 1
    var
  end

  def add_var(var)
    raise CompileError.new("var #{var.id} already defined") if @vars[var.id]
    @vars[var.id] = var
  end

  def new_var(id,type,init,opt,temp=false)
    var = Value.new(id,type,init,opt,self, temp ? :temp : :var )
    add_var(var)
    var
  end

  def find_var(id)
    if @vars[id]
      @vars[id]
    elsif @base and @base.vars[id]
      @base.vars[id]
    else
      raise " #{id} not defined"
    end
  end

  def to_s
    "<Block:#{@id}>"
  end

end

######################################################################
# コンパイラ
######################################################################
class Compiler
  attr_reader :ast, :func ,:vars, :options, :include_bin, :pos_info, :block

  def initialize
    @vars = Hash.new
    @func = Hash.new
    @options = Hash.new
    @include_bin = []
    @pos_info = nil
    @block = nil
  end

  def compile( src )
    ast, @pos_info = Parser.new(src).parse
    puts '====AST===='
    pp ast

    @block = ScopedBlock.new( self, nil, '$root', [] )

    ast.each do |e|
      case e[0] 
      when :function
        @func[e[1]] = Function.new( self, e[1], e[2], e[3], e[4] )
      when :const, :var
        block.ast << e
      when :options
        @options.merge!( e[1] )
      when :include_bin
        @include_bin << e[1]
        if e[1][:name]
          var = Value.new( e[1][:name] )
          var.include_bin = true
          @vars[e[1]] = var
        end
      else
        raise
      end
    end

    # ルートブロックのコンパイル
    @block.compile

    # interruptがない場合は、追加する
    unless @func[:interrupt]
      @func[:interrupt] = Function.new( self, :interrupt, [], :int, [] )
    end

    # アセンブラコードの出力
    opt_asm = []
    inc_asm = []
    var_asm = []
    func_asm = []

    @func.each do |id,f|
      f.block.compile
    end

    @func.each do |id,f|
      puts "\n==function #{f.id}=="
      pp f.args
      pp f.block.vars
      pp f.block.ops
    end

  end

  def find_func( id )
    raise "function #{id} not found " unless @func[id]
    @func[id]
  end

end

if __FILE__ == $0
  $out = 'a.asm'
  opt = OptionParser.new( "NES Compiler\nUsage: fc [options] <src.fc> ...\nOptions:\n" )
  opt.on( '-h', '--help' ){ puts opt; exit }
  opt.on( '-o', 'output file' ){|v| $out = v }
  opt.on( '-r', 'run interpreter' ){ $run = true }
  opt.on( '-S', 'output asm file' ){|v| $asm = true }
  opt.on( '-d', '--debug', 'show debug info' ){|v| $debug_info = true }
  opt.parse!

  asm_file = ARGV[0].sub(/\..+$/){'.asm'}
  src = ARGF.read
    
  com = Compiler.new

  asm = com.compile( src )

  open(asm_file,'w'){|f| f.write asm }

  if $run
    require_relative 'runner'
    puts '====RUN===='
    runner = Runner.new( com )
    runner.run
  end

  unless $asm
    # system( 'nesasm', $out, asm_file )
  end

end

