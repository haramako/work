#!/usr/bin/env ruby -Ku
# coding: utf-8

#
#
#

require 'pp'
require 'optparse'
require_relative 'parser'

def mangle(str)
  str.gsub(/\$|_/){|v| { '$'=>'_V', '_'=>'__' }[v] }
end

######################################################################
# パーサー
######################################################################
class Parser
  def initialize( src )
    @pos = 0
    @src = src
    @pos_info = Hash.new
  end

  def next_token
    next_token2
  end

  def next_token2
    @pos+=1 while /\s/ === @src[@pos]
    return nil if @pos >= @src.size

    c = @src[@pos]
    case c
    when /\//
      # コメント、もしくは '/'
      if @src[@pos+1] == '/'
        mo = @src.match( /\/\/.+/, @pos )
        @pos += mo[0].length
        return next_token
      elsif @src[@pos+1] == '*'
        mo = @src.match( /\/\*.+?\*\//m, @pos )
        @pos += mo[0].length
        return next_token
      else
        @pos += 1
        return [c,c]
      end
    when /\(|\)|\{|\}|;|:|<|>|\[|\]|\+|-|=|,|@|!|\*/ 
      # 記号
      mo = @src.match( /<=|>=|==|!=|\(|\)|\{|\}|;|:|<|>|\[|\]|\+|-|=|,|@|!|\*/, @pos )
      @pos += mo[0].length
      return [mo[0],mo[0]]
    when /\d/
      # 数字
      if @src[@pos,2] == '0x' and mo = @src.match( /0x[0-9a-zA-Z]+/, @pos )
        @pos += mo[0].length
        return [:NUMBER, mo[0].to_i(16) ]
      elsif @src[@pos,2] == '0b' and mo = @src.match( /0b[01]+/, @pos )
        @pos += mo[0].length
        return [:NUMBER, mo[0].to_i(2) ]
      else
        mo = @src.match( /\d+/, @pos )
        @pos += mo[0].length
        return [:NUMBER, mo[0].to_i ]
      end
    when /[a-zA-Z]/ 
      # 識別子/キーワード
      mo = @src.match( /[a-zA-Z0-9_]+/, @pos )
      @pos += mo[0].length
      # キーワードかどうかを判別する
      if /function|const|var|options|if|else|while|return|break|continue|include_bin|int|uint|int8|uint8|int16|uint16/ === mo[0]
        return [mo[0], mo[0]]
      else
        return [:IDENT, mo[0].to_sym ]
      end
    when /"/
      # 文字列
      mo = @src.match( /"([^"]+)"/, @pos )
      @pos += mo[0].length
      return [:STRING, mo[1] ]
    else
      raise "invalid character #{c}"
    end
  end

  def self.parse( src )
    parser = Parser.new( src )
    parser.do_parse
  end
end

######################################################################
# 型
######################################################################
class TypeDecl

  attr_reader :type # 種類( :int, :pointer, :array のいずれか )
  attr_reader :size # サイズ[byte]
  attr_reader :length # 配列の要素数
  attr_reader :signed # signedかどうか(intの場合のみ)
  attr_reader :base # ベース型(pointerとarrayの場合のみ)

  def initialize( ast )
    if String === ast
      @type = :int
      case ast
      when 'int'
        @size = 1
        @signed = true
      when 'uint'
        @size = 1
        @signed = false
      end
    elsif Array === ast 
      if ast[0] == :pointer
        @type = :pointer
        @base = TypeDecl[ ast[1] ]
        @size = 2
      else Array === ast[0] and ast[0][0] == :array
        @type = :array
        @base = TypeDecl[ ast[1] ]
        @length = ast[0][1]
        @size = @base.size * @length
      end
    end
    case @type
    when :int
      @str = ast
    when :pointer
      @str = "#{@base}*"
    when :array
      @str = "#{@base}[#{@length}]"
    else
      raise "invalid type declaration #{ast}"
    end
  end

  def self.[]( ast )
    @@cache = Hash.new unless defined?(@@cache)
    type = TypeDecl.new( ast )
    @@cache[type.to_s] = type unless @@cache[type.to_s]
    @@cache[type.to_s]
  end

  def to_s
    @str
  end

end

######################################################################
# 変数
######################################################################
class Value
  attr_reader :id # 変数名( リテラルの場合は、nil )
  attr_reader :type # TypeDecl
  attr_reader :val # リテラルもしくは定数の値
  attr_reader :opt # オプション
  attr_reader :scope # スコープ(Function)
  attr_reader :temp # テンポラリ変数かどうか

  def self.literal( val )
    Value.new( nil, TypeDecl["int"], val, nil, nil )
  end

  def initialize( id, type, val, opt, scope, temp=false )
    raise "invalid type, #{val}" unless TypeDecl === type
    @id = id
    @type = type
    @val = val
    @opt = opt
    @scope = scope
    @temp = temp
  end

  def left_value?
    @id and not @temp
  end

  def to_s
    if @id
      if @scope
        "#{scope.id}$#{id}:#{type}"
      else
        "#{id}:#{type}"
      end
    else
      @val.inspect
    end
  end

end

######################################################################
# 関数
######################################################################
class Function
  attr_reader :id, :args, :vars, :ast, :ops, :special, :block
  def initialize( global, id, args, ast_or_block )
    @global = global
    @id = id
    @vars = Hash.new
    @arg_len = args.size
    @args = args.map {|v| new_var(*v) }
    if Proc === ast_or_block
      @special = true
      @block = ast_or_block
    else
      @special = false
      @ast = ast_or_block
    end
    @tmp_count = 0
    @label_count = 0
    @ops = []
    @loops = []
  end

  def compile_block( block )
    block.each do |ast|
      exp( ast )
    end
  end

  def exp( ast )
    case ast[0]
    when :var
      ast[1].each do |v|
        new_var v[0], TypeDecl[v[1]], v[2], v[3]
      end
      nil
    when :'if'
      then_label, else_label, end_label = new_labels('then', 'else','end')
      cond = rval(ast[1])
      emit :if, cond, else_label
      emit :label, then_label
      compile_block(ast[2])
      emit :jump, end_label
      emit :label, else_label
      if ast[3]
        compile_block(ast[3])
        emit :label, end_label
      end
      nil
    when :'while'
      begin_label, end_label = new_labels('begin', 'end')
      @loops << end_label
      emit :label, begin_label
      cond = rval(ast[1])
      emit :if, cond, end_label
      compile_block ast[2]
      emit :jump, begin_label
      emit :label, end_label
      @loops.pop
    when :break
      raise "cannot break without loop" if @loops.empty?
      emit :jump, @loops[-1]
    when :return
      emit :return, rval(ast[1])
    when :exp
      rval( ast[1] )
    else
      raise "unknow op #{ast}"
    end
  end

  def rval( ast)
    case ast
    when Symbol
      find_var( ast )
    when Numeric
      Value.literal( ast )
    when String
      # TODO
    when Array
      case ast[0]
      when :load
        left = rval(ast[1])
        right = rval(ast[2])
        compatible_type( left.type, right.type )
        raise "#{left} is not left value" unless left.left_value?
        emit :load, left, right
        left
      when :not, :uminus
        left = rval(ast[1])
        r = new_tmp( left.type )
        emit ast[0], r, left
        r
      when :add, :sub, :mul, :div
        left = rval(ast[1])
        right = rval(ast[2])
        r = new_tmp( compatible_type( left.type, right.type ) )
        emit ast[0], r, left, right
        r
      when :eq, :lt
        left = rval(ast[1])
        right = rval(ast[2])
        compatible_type( left.type, right.type )
        r = new_tmp( TypeDecl["int"] )
        emit ast[0], r, left, right
        r
      when :ne, :gt, :le, :ge
        left = ast[1]
        right = ast[2]
        case ast[0]
        when :ne
          rval([:not, [:eq, left, right]])
        when :gt
          rval([:lt, right, left])
        when :le
          rval([:not, [:lt, right, left]])
        when :ge
          rval([:not, [:lt, left, right]])
        end
      when :call
        func = @global.find_func( ast[1] )
        if func.special
          func.block.call self, *ast[2]
        else
          ast[2].each_with_index do |arg,i|
            emit :load, func.args[i], rval(arg)
          end
          emit :call, func
        end
      else
        raise "unknown op #{ast}"
      end
    else
      raise "unknown op #{ast}"
    end
  end

  def compatible_type( a, b )
    return a if  a == b
    if a.type == :int and b.type == :int
      if a.size > b.size then return a else return b end
    end
    raise "cant convert type #{a} and #{b}"
  end

  def emit( *op )
    @ops << op
  end

  def new_label( name )
    new_labels( [name] )[0]
  end

  def new_labels( *names )
    @label_count += 1
    names.map { |n| '.'+n+'_'+@label_count.to_s }
  end

  def new_tmp( type )
    var = new_var("#{@tmp_count}".intern, type, nil, nil, true )
    @tmp_count += 1
    var
  end

  def new_var(id,type,init,opt,temp=false)
    raise "var #{id} already defined" if @vars[id]
    var = Value.new(id,type,init,opt,self,temp)
    @vars[id] = var
    var
  end

  def find_var(id)
    if @vars[id]
      @vars[id]
    elsif @global.vars[id]
      @global.vars[id]
    else
      raise "var #{id} not defined"
    end
  end

  def to_s
    "<Function:#{id}>"
  end

end

######################################################################
# コンパイラ
######################################################################
class Compiler
  attr_reader :ast, :func ,:vars, :options, :include_bin

  def initialize
    @vars = Hash.new
    @func = Hash.new
    @options = Hash.new
    @include_bin = []
  end

  def compile( src )
    ast = Parser.parse( src )
    pp ast
    ast.each do |e|
      case e[0] 
      when :function
        @func[e[1]] = Function.new( self, *e[1..-1] )
      when :const
        var = Value.new( e[1] )
        var.val = e[2]
        @vars[e[1]] = var
      when :var
        e[1].each do |v|
          @vars[v[0]] = Value.new( v[0], TypeDecl[v[1]], v[2], v[3], nil )
        end
      when :options
        @options.merge!( e[1] )
      when :include_bin
        @include_bin << e[1]
        if e[1][:name]
          var = Value.new( e[1][:name] )
          var.include_bin = true
          @vars[e[1]] = var
        end
      else
        raise
      end
    end

    # interruptがない場合は、追加する
    unless @func[:interrupt]
      @func[:interrupt] = Function.new( self, :interrupt, [], [] )
    end

    # アセンブラコードの出力
    opt_asm = []
    inc_asm = []
    var_asm = []
    func_asm = []

    opt_asm << "; options"
    @options.each do |opt,val|
      if [:inesprg, :ineschr, :inesmir, :inesmap].include?(opt)
        opt_asm << "    .#{opt} #{val};"
      end
    end

    inc_asm << '; include_bin'
    @include_bin.each do |inc|
      if inc[:bank]
        inc_asm << "    .bank #{inc[:bank]}"
        inc_asm << "    .org #{inc[:address] or 0}" 
        inc_asm << "    .incbin \"#{inc[:file]}\""
      else
        func_asm << "#{inc[:name]}: .incbin \"#{inc[:file]}\""
      end
    end

    var_asm << "; global"
    @vars.each do |id,v|
      #if v.include_bin or v.val
        # DO NOTHING
      #elsif v.address
        # var_asm << "#{v.to_asm} = $#{'%4x'%[v.address]}"
      #else
        # var_asm << "#{v.to_asm} .ds 1"
      #end
    end

    @func.each do |id,f|
      next unless f.ast
      func_asm << "; function #{id}"
      func_asm << "#{id}:"

      f.compile_block( f.ast )

      var_asm << "; function #{id}"
      # func_asm.concat OpCompiler.compile( f.ops )
      func_asm << "    rts"

      f.vars.each do |id,v|
        if v.val
          # func_asm << "#{v.to_asm} .db \"#{v.val}\",0"
        else
          # var_asm << "#{v.to_asm} .ds 1"
        end
      end
    end

    @func.each do |id,f|
      puts 
      pp f
      pp f.args
      pp f.vars
    end

  end

  def find_func( id )
    raise "function #{id} not found " unless @func[id]
    @func[id]
  end

end

if __FILE__ == $0
  $out = 'a.asm'
  opt = OptionParser.new( "NES Compiler\nUsage: fc [options] <src.fc> ...\nOptions:\n" )
  opt.on( '-h', '--help' ){ puts opt; exit }
  opt.on( '-o', 'output file' ){|v| $out = v }
  opt.on( '-S', 'output asm file' ){|v| $asm = true }
  opt.on( '-d', '--debug', 'show debug info' ){|v| $debug_info = true }
  opt.parse!

  asm_file = ARGV[0].sub(/\..+$/){'.asm'}
  src = ARGF.read
    
  @com = Compiler.new

  asm = @com.compile( src )

  if $debug_info
    pp @com
    @com.func.each { |id,f| puts f; pp f.ops }
  end

  open(asm_file,'w'){|f| f.write asm }

  unless $asm
    # system( 'nesasm', $out, asm_file )
  end

end

