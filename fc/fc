#!/usr/bin/env ruby -Ku
# coding: utf-8

#
#
#

require 'pp'
require 'optparse'
require 'strscan'
require 'erb'
require_relative 'parser'

######################################################################
# パーサー
######################################################################
class Parser

  def initialize( src, filename='(unknown)' )
    @filename = filename
    @scanner = StringScanner.new(src)
    @line_no = 1
    @pos_info = Hash.new
  end

  def next_token
    # コメントと空白を飛ばす
    while @scanner.scan(/ \s+ | \/\/.+?\n | \/\*.+?\*\/ /mx)
      @scanner[0].gsub(/\n/){ @line_no += 1 }
    end
    if @scanner.eos?
      r = nil
    elsif @scanner.scan(/<=|>=|==|\+=|-=|!=|->|\(|\)|\{|\}|;|:|<|>|\[|\]|\+|-|\*|\/|=|,|@|!/)
      # 記号
      r = [@scanner[0], @scanner[0]]
    elsif @scanner.scan(/0[xX]([\d\w]+)/)
      # 16進数
      r = [:NUMBER, @scanner[1].to_i(16)]
    elsif @scanner.scan(/0[bB](\d+)/)
      # 2進数
      r = [:NUMBER, @scanner[1].to_i(2)]
    elsif @scanner.scan(/\d+/)
      # 10進数
      r = [:NUMBER, @scanner[0].to_i]
    elsif @scanner.scan(/\w+/)
      # 識別子/キーワード
      if /^(include|function|const|var|options|if|else|loop|while|return|break|continue|include_bin)$/ === @scanner[0]
        r = [@scanner[0], @scanner[0]]
      else
        r = [:IDENT, @scanner[0].to_sym ]
      end
    elsif @scanner.scan(/"([^\\"]|\\.)*"/)
      # ""文字列
      r = [:STRING, @scanner[0][1..-2]]
    elsif @scanner.scan(/'([^\\']|\\.)*'/)
      # ''文字列
      r = [:STRING, @scanner[0][1..-2]]
    else
      raise "invalid token at #{@line_no}"
    end
    # pp r
    r
  end

  def info( ast )
    @pos_info[ast] = [@filename,@line_no,@line_str]
  end

  def parse
    ast = do_parse
    [ast, @pos_info]
  end

  def on_error( token_id, err_val, stack )
    puts "#{@filename}:#{@line_no}: error with #{token_id}"
    # pp token_id, err_val, stack
    super
  end
end

######################################################################
# 型
######################################################################
class TypeDecl

  attr_reader :type # 種類( :void, :int, :pointer, :array, :lambda のいずれか )
  attr_reader :size # サイズ(単位:byte)
  attr_reader :signed # signedかどうか(intの場合のみ)
  attr_reader :base # ベース型(pointerとarrayの場合のみ)
  attr_reader :length # 配列の要素数(arrayのみ)
  attr_reader :args # 引数クラスのリスト(lambdaの場合のみ)

  BASIC_TYPES = { int:[1,true], uint:[1,false], int8:[1,true], uint8:[1,false], int16:[2,true], uint16:[2,false] }

  def initialize( ast )
    if ast == :void
      @type = :void
      @size = 1
    elsif Symbol === ast
      @type = :int
      if BASIC_TYPES[ast]
        @size = BASIC_TYPES[ast][0]
        @signed = BASIC_TYPES[ast][1]
      else
        raise
      end
    elsif Array === ast 
      if ast[0] == :pointer
        @type = :pointer
        @base = TypeDecl[ ast[1] ]
        @size = 2
      elsif ast[0] == :array
        @type = :array
        @base = TypeDecl[ ast[2] ]
        @length = ast[1]
        @size = @base.size * @length
      elsif ast[0] == :lambda
        @type = :lambda
        @base = TypeDecl[ ast[2] ]
        @args = ast[1]
        @size = 2
      end
    end

    case @type
    when :int, :void
      @str = "#{ast}"
    when :pointer
      @str = "*#{@base}"
    when :array
      @str = "[#{@length}]#{@base}"
    when :lambda
      @str = "(#{args.join(",")}):#{@base}"
    else
      raise "invalid type declaration #{ast}"
    end
  end

  def to_s
    @str
  end

  def self.[]( ast_or_type )
    return ast_or_type if TypeDecl === ast_or_type
    @@cache = Hash.new unless defined?(@@cache)
    type = TypeDecl.new( ast_or_type )
    @@cache[type.to_s] = type unless @@cache[type.to_s]
    @@cache[type.to_s]
  end

end

######################################################################
# 値を持つもの(変数、テンポラリ変数、リテラル、定数など）
######################################################################
class Value
  attr_reader :kind # 種類( :var, :const, :literal のいずれか）
  attr_reader :id # 変数名( リテラルの場合は、nil )
  attr_reader :type # TypeDecl
  attr_reader :val # リテラルもしくは定数の場合は数値
  attr_reader :opt # オプション
  attr_reader :scope # スコープ(Function)
  attr_reader :var_type # varのときのみ( :var, :temp, :arg, :reterun_val のいずれか )

  # 以下は、アセンブラで使用
  attr_accessor :address # アドレス
  attr_accessor :lr # 生存期間([from,to]という２要素の配列)
  attr_accessor :nonlocal # クロージャから参照されているかどうか
  attr_accessor :reg # 格納場所( :mem, :none, :a, :carry, :not_carry, :zero, :not_zero, :negative, :not_negative のいずれか )

  def self.literal( val )
    Value.new( nil, TypeDecl[:int], val, nil, nil, :literal, nil )
  end

  def initialize( id, type, val, opt, scope, kind=:var, var_type )
    raise "invalid type, #{type}" unless TypeDecl === type
    @id = id
    @type = type
    @val = val
    @opt = opt
    @scope = scope
    @kind = kind
    @var_type = var_type
  end

  def assignable?
    ( ( @kind == :var and @var_type != :temp ) or @type.type == :pointer )
  end

  def const?
    ( @kind != :var )
  end

  def to_s
    if @id
      if @scope
        "#{scope.id}$#{id}:#{type}"
      else
        "#{id}:#{type}"
      end
    else
      @val.inspect
    end
  end

end

# エラークラス
class CompileError < RuntimeError
  attr_accessor :line
  attr_accessor :file
end

######################################################################
# 関数
######################################################################
class Lambda
  attr_reader :id, :type, :args, :block
  def initialize( id, type, args, block )
    @id = id
    @type = type
    @args = args
    @block = block
  end

  def to_s
    "<Lambda:#{@id}#{@type}>"
  end
end

######################################################################
# スコープ付きブロック
######################################################################
class ScopedBlock
  attr_reader :upper, :id, :ast, :vars, :ops, :options
  attr_accessor :asm

  def initialize( compiler, upper, id, ast )
    @compiler = compiler
    @upper = upper
    @id = id
    @ast = ast
    @vars = Hash.new
    @tmp_count = 1
    @label_count = 0
    @ops = []
    @options = Hash.new
    @asm = []
    @loops = []
    @cur_filename = nil
    @cur_line = 0
    @cur_line_str = nil
  end

  def compile
    begin
      # メインブロックのコンパイル
      compile_block( @ast )

      # returnを追加する
      if @ops[-1].nil? or @ops[-1][0] != :return
        if @vars[:'0']
          raise CompileError.new( "no return" )
        else
          emit :return
        end
      end

      # lambdaのコンパイル
      @vars.each do |id,v|
        if v.val and Lambda === v.val
          v.val.block.compile
        end
      end
=begin
      puts "====FUNCTION===="
      puts @id
      pp @ast
      pp @ops
=end

    rescue CompileError
      puts @cur_line_str if @cur_line_str
      puts "#{@cur_filename}:#{@cur_line_no}: #{$!}"
      raise
    end
  end

  def compile_block( ast )
    ast.each do |stat|
      compile_statement( stat )
    end
  end

  def compile_statement( ast )
    update_pos( ast )
    case ast[0]
    when :options
      @options.merge!( ast[1] )

    when :include_bin
      @include_bin << e[1]
      if e[1][:name]
        var = Value.new( e[1][:name] )
        var.include_bin = true
        @vars[e[1]] = var
      end

    when :include
      filename = ast[1]
      src = File.read(filename)
      ast, pos_info = Parser.new(src,filename).parse
      @compiler.pos_info.merge!( pos_info )
      compile_block( ast )

    when :function
      block = ScopedBlock.new( @compiler, self, ast[1], ast[4] )
      args = ast[2].map do |v|
        block.new_arg( v[0], TypeDecl[v[1]] )
      end
      type = TypeDecl[ [:lambda, args, ast[3]] ]
      lmd = Lambda.new( ast[1], type, args, block )
      block.new_return_val(type.base) if type.base != TypeDecl[:void]
      new_const( ast[1], lmd.type, lmd, nil )

    when :var
      ast[1].each do |v|
        var = new_var( v[0], TypeDecl[v[1]], nil, v[3] )
        compile_statement( [:exp, [:load, var.id, v[2]]] ) if v[2]
      end

    when :const
      ast[1].each do |v|
        raise CompileError.new("connot define const without value #{v[0]}") unless v[2]
        new_const( v[0], TypeDecl[v[1]], const_eval( v[2] ), v[3] )
      end

    when :'if'
      then_label, else_label, end_label = new_labels('then', 'else','end')
      cond = rval(ast[1])
      emit :if, cond, else_label
      emit :label, then_label
      compile_block(ast[2])
      emit :jump, end_label
      emit :label, else_label
      if ast[3]
        compile_block(ast[3])
      end
      emit :label, end_label

    when :loop
      begin_label, end_label = new_labels('begin', 'end')
      @loops << end_label
      emit :label, begin_label
      compile_block ast[1]
      emit :jump, begin_label
      emit :label, end_label
      @loops.pop
      
    when :'while'
      begin_label, end_label = new_labels('begin', 'end')
      @loops << end_label
      emit :label, begin_label
      cond = rval(ast[1])
      emit :if, cond, end_label
      compile_block ast[2]
      emit :jump, begin_label
      emit :label, end_label
      @loops.pop

    when :break
      raise CompileError.new("cannot break without loop") if @loops.empty?
      emit :jump, @loops[-1]

    when :return
      if @vars[:'0']
        # 非void関数
        raise CompileError.new("can't return without value") unless ast[1]
        emit :return, rval(ast[1])
      else
        # void関数
        raise CompileError.new("can't return from void function") if ast[1]
        emit :return
      end

    when :exp
      const_eval( ast[1] )
      rval( ast[1] )

    else
      raise "unknow op #{ast}"
    end
  end

  def rval( ast )
    v, left = lval( ast )
    if left
      r = new_tmp( v.type.base )
      emit :pget, r, v
      r
    else
      v
    end
  end

  def lval( ast )
    left_value = false
    case ast
    when Symbol
      r = find_var( ast )

    when Numeric
      r = Value.literal( ast )

    when String
      r = new_literal_string(ast)

    when Array
      case ast[0]

      when :load
        left, left_value = lval(ast[1])
        right = rval(ast[2])
        if left_value
          compatible_type( left.type.base, right.type )
          raise CompileError.new("#{left} is not left value") unless left.assignable?
          emit :pset, left, right
          r = left
          left_value = true
        else
          compatible_type( left.type, right.type )
          raise CompileError.new("#{left} is not left value") unless left.assignable?
          emit :load, left, right
          r = left
        end

      when :not, :uminus
        left = rval(ast[1])
        r = new_tmp( left.type )
        emit ast[0], r, left

      when :add, :sub, :mul, :div
        left = rval(ast[1])
        right = rval(ast[2])
        r = new_tmp( compatible_type( left.type, right.type ) )
        emit ast[0], r, left, right

      when :eq, :lt
        left = rval(ast[1])
        right = rval(ast[2])
        compatible_type( left.type, right.type )
        r = new_tmp( TypeDecl[:int] )
        emit ast[0], r, left, right

      when :ne, :gt, :le, :ge
        # これらは、eq,lt の引数の順番とnotを組合せて合成する
        left = ast[1]
        right = ast[2]
        case ast[0]
        when :ne
          r = rval([:not, [:eq, left, right]])
        when :gt
          r = rval([:lt, right, left])
        when :le
          r = rval([:not, [:lt, right, left]])
        when :ge
          r = rval([:not, [:lt, left, right]])
        end

      when :call
        func = find_var( ast[1] )
        if func.type.base.type != :void
          r = new_tmp( func.type.base )
        else
          r = nil
        end
        raise CompileError.new("lambda #{func} has #{func.val.args.size} but #{ast[2].size}") if ast[2].size != func.val.args.size
        args = []
        ast[2].each_with_index do |arg,i|
          v = rval(arg)
          compatible_type( func.val.args[i].type, v.type )
          args << v
        end
        emit :call, r, func, *args

      when :index
        left = rval(ast[1])
        right = rval(ast[2])
        raise CompileError.new("index must be pointer or array") unless left.type.type == :pointer or left.type.type == :array
        raise CompileError.new("index must be int") if right.type.type != :int
        r = new_tmp( TypeDecl[[:pointer, left.type.base]] )
        emit :index, r, left, right
        left_value = true

      else
        raise "unknown op #{ast}"
      end
    else
      raise "unknown op #{ast}"
    end
    [r,left_value]
  end

  def const_eval( ast )
    r = ast
    case ast
    when Symbol
      var = find_var( ast )
      r = var.val if var.const?
    when Numeric
      r = ast
    when String
      r = ast
    when Array
      case ast[0]
      when :array
        r = [:array, ast[1].map{|v| const_eval(v)} ]
      when :add, :sub, :mul, :div, :eq, :ne, :lt, :gt, :le, :ge
        ast[1] = const_eval( ast[1] )
        ast[2] = const_eval( ast[2] )
        if Numeric === ast[1] and Numeric === ast[2]
          case ast[0]
          when :add then r = ast[1] +  ast[2]
          when :sub then r = ast[1] -  ast[2]
          when :mul then r = ast[1] *  ast[2]
          when :div then r = ast[1] /  ast[2]
          when :eq  then r = ast[1] == ast[2]
          when :ne  then r = ast[1] != ast[2]
          when :lt  then r = ast[1] <  ast[2]
          when :gt  then r = ast[1] >  ast[2]
          when :le  then r = ast[1] <= ast[2]
          when :ge  then r = ast[1] >= ast[2]
          end
        end
      when :not, :uminus
        ast[1] = const_eval( ast[1] )
        if Numeric === ast[1]
          case ast[0]
          when :not then r = ~ast[1]
          when :uminus then r = -ast[1]
          end
        end
      end
    end
    r
  end

  def compatible_type( a, b )
    return a if  a == b
    if a.type == :int and b.type == :int
      if a.size > b.size then return a else return b end
    elsif a.type == :pointer and b.type == :array and a.base == b.base
      return a
    end
    raise CompileError.new("cant convert type #{a} and #{b}")
  end

  def update_pos( ast )
    if @compiler.pos_info[ast]
      pos_info = @compiler.pos_info[ast]
      @cur_filename, @cur_line_no, @cur_line_str = @compiler.pos_info[ast]
      # puts "compiling ... line #{@cur_line}"
    end
  end

  def emit( *op )
    @ops << op
  end

  def new_label( name )
    new_labels( [name] )[0]
  end

  def new_labels( *names )
    @label_count += 1
    names.map { |n| '.'+n+'_'+@label_count.to_s }
  end

  def add_var(var)
    raise CompileError.new("var #{var.id} already defined") if @vars[var.id]
    @vars[var.id] = var
    var
  end

  def new_var(id,type,init,opt)
    add_var Value.new(id,type,init,opt,self, :var, :var )
  end

  def new_const(id,type,init,opt)
    case init
    when nil, Numeric, Lambda
    when String
      init = str.unpack('c*').concat([0])
    when Array
      if init[0] == :array
        init = init[1]
      else
        raise "not constant value #{@init}"
      end
    else
      raise "not constant value #{@init}"
    end
    add_var Value.new(id,type,init,opt,self, :const, nil )
  end

  def new_tmp( type )
    var = add_var( Value.new("#{@tmp_count}".intern,type,nil,nil,self, :var, :temp) )
    @tmp_count += 1
    var
  end

  def new_arg(id,type)
    add_var Value.new(id,type,nil,nil,self, :var, :arg)
  end

  def new_return_val(type)
    add_var Value.new(:'0',type,nil,nil,self, :var, :return_val )
  end

  def new_literal_string(str)
    var = add_var( Value.new("#{@tmp_count}".intern, 
                             TypeDecl[[:array,str.size+1,:int]], 
                             str.unpack('c*').concat([0]), nil, self, :const, nil ) )
    @tmp_count += 1
    var
  end

  def find_var(id)
    if @vars[id]
      @vars[id]
    elsif @upper 
      @upper.find_var(id)
    else
      raise " #{id} not defined"
    end
  end

  def to_s
    "<Block:#{@id}>"
  end

end

######################################################################
# コンパイラ
######################################################################
class Compiler
  attr_reader :ast, :func ,:vars, :options, :include_bin, :pos_info, :root

  def initialize
    @pos_info = nil
  end

  def compile( src, filename=nil )
    ast, @pos_info = Parser.new(src,filename).parse

    @root = ScopedBlock.new( self, nil, :'', ast )
    @root.compile

    # interruptがなかったら足す
    unless @root.vars[:interrupt]
      blk = ScopedBlock.new(self,@root,:interrupt,[])
      blk.compile
      lmd = Lambda.new(:interrupt,TypeDecl[[:lambda,[],:void]],[],blk)
      @root.new_const(:interrupt,lmd.type,lmd,nil)
    end
  end

  def to_html
    template = <<EOT
<html>
<head><title>hoge</title></head>
<body>
<style>
table { border-collapse: collapse; }
th { border: solid 1px #888; background-color: #ddd; }
td { border: solid 1px #888; }
.block { margin-left: 40px; }
h1 { border-bottom: solid 1px #00f; }
.code { font-family: 'Osaka-等幅', 'Osaka-Mono', monospace; border: solid 1px #ddd; }
</style>
<h1>(root block)</h1>
<%= block_to_html(@root) %>
</body>
</html>
EOT
    ERB.new(template,nil,'-').result(binding)
  end

  def block_to_html(block)
    template = <<EOT
<h2>variables</h2>
<table>
  <tr><th>id</th><th>type</th><th>address</th><th>value</th><th>opt</th><th>kind</th><th>live</th><th>reg</th></tr>
  <%- block.vars.each do |id,v| -%>
    <tr>
      <td><%= id %></td>
      </td><td><%= v.type %></td>
      </td><td><%= v.address and "0x%04x"%[v.address]  %></td>
      <td><%= if Lambda === v.val then '(lambda)' else  v.val end %></td>
      <td><%= v.opt %></td></p>
      <td><%= v.kind %></td></p>
      <td><%= v.lr %></td></p>
      <td><%= v.reg %></td></p>
  <%- end -%>
</table>

<h2>ast</h2>
<pre class="code"><%= PP.pp(block.ast,'') %></pre>

<h2>code</h2>
<pre class="code">
<%- block.ops.each_with_index do |op,i| -%>
<%= "<font color=\\"#aaa\\">%04d:</font> %-6s %s"%[i, op[0], op[1..-1].join(", ")] %>
<%- end %></pre>

<h2>asm</h2>
<pre class="code">
<%- block.asm.each do |line| -%>
<%- if /^\\s+;/ === line -%>
<font color="green"><%= line %></font>
<%- elsif /^[.\\w]+:/ === line -%>
<font color="#88f"><%= line %></font>
<%- else -%>
<%= line %>
<%- end -%>
<%- end -%>
</pre>

<%- block.vars.each do |id,v| -%>
  <%- if v.type.type == :lambda and v.val -%>
    <div class="block">
      <a name="<%=id%>"></a>
      <h1>function <%= v.id %>(<%= v.val.args.map{|a| "\#{a.id}:\#{a.type}"}.join(", ") %>):<%= v.type.base %></h1>
      <%= block_to_html(v.val.block) %>
    </div>
  <%- end -%>
<%- end -%>
EOT
    ERB.new(template,nil,'-').result(binding)
  end

end

if __FILE__ == $0
  $out = 'a.nes'
  opt = OptionParser.new( "NES Compiler\nUsage: fc [options] <src.fc> ...\nOptions:\n" )
  opt.on( '-h', '--help' ){ puts opt; exit }
  opt.on( '-o', 'output file' ){|v| $out = v }
  opt.on( '-e', 'run by interpreter' ){ $run = true }
  opt.on( '-S', 'output asm file' ){|v| $asm = true }
  opt.on( '-d', '--debug', 'show debug info' ){|v| $debug_info = true }
  opt.parse!

  base = File.basename($out,'.*')
  src_filename = ARGV[0]
  src = File.read(src_filename)

  # ソースコードを中間コードのコンパイル
  com = Compiler.new
  com.compile( src, src_filename )

  if $debug_info
    open( base+'.html', 'w' ) do |f|
      f.write com.to_html
    end
  end

  if $run
    require_relative 'runner'
    puts '====RUN===='
    runner = Runner.new( com )
    runner.run
    exit
  end

  # 中間コードをアセンブラにコンパイルする
  require_relative 'asm'
  op_com = OpCompiler.new
  op_com.compile( com.root )

  if $debug_info
    open( base+'.html', 'w' ) do |f|
      f.write com.to_html
    end
  end

  template = <<EOT
@OPTIONS
	.bank 2
	.org $0000
	.incbin "character.chr"
	.incbin "character.chr"

	.bank 1
	.org $FFFA
	.dw __interrupt
	.dw __start
	.dw 0

	.bank 0
__reg = 0 ; 汎用レジスタ

	.org $8000
__start:
	sei
	ldx #255
	txs
	jsr __init
.loop:
    jmp .loop

__interrupt:
    pha
    txa
    pha
    tya
    pha
    jsr _Vinterrupt
    pla
    tay
    pla
    tax
    pla
    rti

@CODE
EOT

  options = { inesprg: 1, ineschr: 1, inesmir: 0, inesmap: 0 }
  options.merge!( com.root.options )
  options_asm = options.map{|k,v| "\t.#{k} #{v}" }

  str = template
    .gsub(/@OPTIONS/){options_asm.join("\n")}
    .gsub(/@INCLUDES/){''}
    .gsub(/@CODE/){op_com.asm.join("\n")}

  open( base+'.asm', 'w' ) do |f|
    f.write str
  end

  unless $asm
    puts '====ASSEMBLE====' if $debug_info
    if system( '/Users/makoto/bin/nesasm', base+'.asm' ).nil?
      raise 'cannot exec nesasm'
    end
  end

end

