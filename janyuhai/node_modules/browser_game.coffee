# nodeとブラウザの両対応用, nodeの場合はそのままで,ブラウザの場合はwindowをexportsとする
if typeof(module) == 'undefined' and typeof(exports) == 'undefined'
    eval('var exports, global; exports = {}; window["browser_game"] = exports; global = window;')

_ = require 'underscore'
jan = require 'jan'
game = require 'jan/game'

class Game
    constructor: (player=undefined)->
        # HTMLエレメントの取得
        @takuDiv = $('#taku')
        @stateDiv = $('#state')
        @tehaiDiv = ($("#tehai#{i}") for i in [0..3])
        @kawaDiv = ($("#kawa#{i}") for i in [0..3] )
        @choiseDiv = $("#choises")
        @haifuDiv = $('#haifu')
        @autoplay = [false,true,true,true]

        # イベントハンドラの設定
        @takuDiv.on 'click', (ev)=>
            cls = $(ev.target).attr('class')
            if cls == 'hai'
                @onHaiClick( $(ev.target).data('pi') )
            else if cls == 'autoplay'
                idx = parseInt( $(ev.target).data('idx'), 10 )
                @autoplay[idx] = !@autoplay[idx]
            true

        @choiseDiv.on 'click', (ev)=>
            cls = $(ev.target).attr('class')
            if cls == 'choise'
                @onChoiseClick( parseInt( $(ev.target).data('choise'),10) )
            true

        @player = player
        @choises = []
        if @player?
            @game = new game.Game(@player, [],{})
        else
            @game = new game.Game(game.GameMode.MASTER, [],{})

    showGame: ()->
        # ログの表示
        @haifuDiv.text( jan.prettyPrint(@game.record) )

        # 状態の表示
        pos = @game.splitPos(@game.tsumoPos)
        @stateDiv.html "state=#{@game.state} curPlayer=#{@game.curPlayer} tsumoPos=#{@game.tsumoPos}\n"+
            "残り#{@game.restPai()}枚 ツモ位置[#{'東南西北'[pos.yama]},#{pos.ton},#{if pos.top then '上' else '下'}]\n"+
            "ドラ表示牌: #{@haiToHtml(@game.piDoraIndicator)}"

        for player,i in @game.p
            @tehaiDiv[i].removeClass('active_dahai')
            @tehaiDiv[i].removeClass('active')
            if @game.curPlayer == i
                if @game.state == 'DAHAI'
                    @tehaiDiv[i].addClass 'active_dahai'
                else
                    @tehaiDiv[i].addClass 'active'

            # 手牌/副露牌を表示
            html = ''
            if @game.isOwner(i)
                html = @haiToHtml( player.s.piTehai )
            else
                html = @haiToHtml( (jan.PaiId.HAKU_0 for n in [0...player.tehaiNum] ) )
            html += ' '+@mentsuToHtml( mentsu ) for mentsu in player.furo
            @tehaiDiv[i].html(html)

            # 名前を表示
            nameDiv = $("<div>").text("P[#{player.initIdx}]　")
            $('<input type="checkbox" class="autoplay" data-idx="'+i+'" '+(if @autoplay[i] then 'checked="checked"' else'')+'">自動</input>').appendTo(nameDiv)
            nameDiv.append("　#{player.score}点")
            @tehaiDiv[i].prepend(nameDiv)

            # 6枚ごとに分けて川牌を表示
            html = ''
            for pi,n in player.piKawahai
                if player.kawahaiState[n] == game.KawaState.NAKI
                    html += @haiToHtml( pi, 'naki' )
                else if player.kawahaiState[n] == game.KawaState.REACH
                    html += @haiToHtml( pi, 'reach' )
                else
                    html += @haiToHtml( pi )
                html += "<br/>" if n % 6 == 5

            @kawaDiv[i].html(html)

        unless @player?
            @choises = @game.choises
        @choiseDiv.empty()
        for c,i in @choises
            div = $('<div class="choise">').html( ''+i+':'+JSON.stringify(c) ).data({choise:i})
            @choiseDiv.append( div )

    send: (com,skip=true,display=true,autoplay=true)->
        @game.progress com

        # 理牌する
        if com.type == 'DAHAI' or com.type == 'HAIPAI'
            player = @game.p[com.pl]
            player.s.piTehai.sort (a,b)->a-b

        unless @player?
            # skipが真で選択肢がないなら勝手にすすめる
            if skip and @game.choises.length == 1
                @send @game.choises[0]
            else
                # 自動プレイならすすめる
                choises = _.filter( @game.choises, (c)=>( c.pl? and not @autoplay[c.pl] ) )
                if autoplay and choises.length == 0
                    @send @game.choises[0]
                else
                    # 選択肢がのこってるなら選択する
                    @showGame() if display
        else
            @showGame() if display

    choose: (com)->
        unless @player?
            @send com, false, true, false
        else
            @choises = []
            @onChoose com

    onChoose: (com)->0


    onHaiClick: (pi)->
        if @game.state == 'DAHAI'
            player = @game.p[@game.curPlayer]
            if player.s.piTehai.indexOf(pi) >= 0
                @choose { type:'DAHAI', pl:@game.curPlayer, pub:{pi:pi} }

    onChoiseClick: (idx)->
        @choose @choises[idx]

    # 牌をHTMLに変換する.
    # @param pi PaiId(もしくはPaiIdの配列)
    # @param cls クラス
    # @return html文字列
    haiToHtml: (pi,cls)->
        if typeof pi == 'number'
            pk = jan.PaiId.toKind(pi)
            img= if pk >= 10 then ''+pk else ('0'+pk)
            if pi == jan.PaiId.MAN5_3 or pi == jan.PaiId.PIN5_3 or pi == jan.PaiId.SOU5_3
                img += 'r'
            c = 'hai'
            c += ' '+cls if cls
            '<img class="'+c+'" data-pi="'+pi+'" src="./img/'+img+'.gif" />'
        else
            pi.map( (piOne)=>@haiToHtml(piOne) ).join('')

    # 面子をHTMLに変換する
    # @param mentsu 対象のMentsuオブジェクト
    # @return html文字列
    mentsuToHtml: (mentsu)->
        @haiToHtml( mentsu.pis )

class AdminClient
    constructor: (host,port,callback)->
        @host = host
        @port = port or 20001
        @messageId = 0
        @callbackById = {}
        @ws = new WebSocket("ws://#{@host}:#{@port}/admin",'janyuhai-game-admin')
        @ws.onmessage = (ev)=>
            msg = JSON.parse( ev.data )
            if msg.id?
                callback = @callbackById[msg.id]
                callback(msg) if callback
                delete @callbackById[msg.id]
            else
                puts "unknown message, msg=#{JSON.stringify(msg)}"
        @ws.onopen = (ev)=>
            puts 'admin-client connected'
            callback(this)
        @ws.onclose = (ev)=>
            puts 'admin-client closed'

    send: (msg,callback)->
        msg.id = @messageId
        @callbackById[msg.id] = callback
        @messageId++
        @ws.send JSON.stringify(msg)

    close: ->
        @ws.close()

class Client
    constructor: (host,port,pid)->
        @game = undefined
        @messageId = 0
        @pid = pid
        @ws = new WebSocket("ws://#{host}:#{port}/#{@pid}", 'janyuhai-game')

        @ws.onopen = (ev)=>
            puts 'client connect'
            @game = new game.Game( 0, [], {} )

        @ws.onmessage = (ev)=>
            msg = JSON.parse( ev.data )
            @oncommand msg

        @ws.onclose = (ev)->
            puts 'client close'

    send: (msg)->
        puts msg
        msg.id = @messageId
        @messageId++
        @ws.send JSON.stringify(msg)

    oncommend: (msg)->0

uuid = ->
    ''+Math.floor(Math.random()*10000)

parseParams = ->
    param = {}
    for s in document.location.search.substring(1).split('&')
        kv = s.split('=')
        param[kv[0]] = kv[1]
    param

startGameHtml = ->
    $(document).ready ->
        # GETパラメータの解析
        param = parseParams()
        puts 'param=',param

        createAdmin = ->
            window.admin = new AdminClient param.host, param.port, (conn)->
                sid = uuid()
                pids = (uuid() for i in [0...4])
                conn.send {t:'CREATE_SESSION', sid:sid, pids:pids }, ->
                    puts 'create session ok'
                createClient(pids[0])

        g = undefined
        createClient = (pid)->
            window.cli = cli = new Client(param.host, param.port, pid)
            cli.oncommand = (msg)->
                switch msg.t
                 when 'LOGIN'
                    puts 'login'
                    window.g = g = new Game(msg.idx)
                    g.onChoose = (com)->
                        cli.send {t:'CHOOSE', com:com}
                    g.showGame()
                 when 'COM'
                    g.send msg.com, false, true, false
                 when 'CHOISES'
                    g.choises = msg.ch
                    g.showGame()
                 when 'CHOOSE_R'
                    0
                 else
                    throw "invalid msg.t=#{msg.t}"

        # パラメータごとに状況を分解
        # hostがあり、pidがある
        # haifuがある
        # いずれもない
        if param.haifu
            $.getJSON param.haifu, (data)->
                window.g = g = new Game(pl)
                unless data.version
                    data = game.Game.makeCheatHaifu( data )
                for com in data.haifu
                    g.send com, false, false, false
                g.showGame()

        else
            #window.g = g = new Game(pl)
            #g.showGame()
            if param.host?
                createClient(param.pid)


        puts 'ready'

startIndexHtml = ->
    # GETパラメータの解析
    param = parseParams()
    puts 'param=',param

    host = param.host or location.host
    port = param.port or 20001

    $(document).ready ->
        window.admin = new AdminClient host, port, (conn)->
            reloadSession()
        $('#create_session').click (ev)->
            pids = (uuid() for i in [0...4])
            window.admin.send {t:'CREATE_SESSION', sid:uuid(), pids:pids}, (msg)->
                reloadSession()

    reloadSession = ->
        window.admin.send {t:'SESSION_LIST'}, (msg)->
            table = $('#sessions')
            table.html( '<tr><th>session</th><th>players</th></tr>' )
            for s in msg.sessions
                html = "<tr><td>#{s.sid}</td><td>"
                html += '<a href="game.html?host='+host+'&port='+port+'&pid='+pid+'">プレイヤー'+i+'</a>　' for pid,i in s.players
                html += '</td></tr>'
                table.append( $(html) )


exports.Game = Game
exports.AdminClient = AdminClient
exports.Client = Client
exports.startGameHtml = startGameHtml
exports.startIndexHtml = startIndexHtml
