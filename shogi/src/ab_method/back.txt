package ab_method

import (
	// "fmt"
	// "strings"
	"math"
)

type Param struct {
	Limit int
	Level int
	MaxLevel int
	Positive bool
}

type Node interface {
	String() string
	Choices() []string
	Choose( string ) Node
	Point() int
	Stop() bool
}

type Walker interface {
	Inspect( Node )
}

func solvNode( param Param, node Node ) ( []string, int ) {
	// fmt.Printf( "%ssolving: %s alpha:%d\n", strings.Repeat("  ", param.Level), node, param.Limit )
	choices := node.Choices()
	var r_choices []string
	var r_point int
	if param.Level < param.MaxLevel && !node.Stop() && len(choices) > 0 {
		child_param := param
		child_param.Level += 1
		child_param.Positive = !param.Positive
		if param.Positive {
			r_point = math.MinInt32
		}else{
			r_point = math.MaxInt32
		}
		for _, choice := range choices {
			child := node.Choose( choice )
			child_param.Limit = r_point
			result, point := solvNode( child_param, child )
			if param.Positive {
				if r_point < point {
					r_choices = append( []string{choice}, result... )
					r_point = point
					// アルファカット
					if point >= param.Limit { 
						// fmt.Printf("%salpha cut %v %d\n", strings.Repeat("  ", child_param.Level), child, point);
						break
					}
				}
			}else{
				if r_point > point {
					r_choices = append( []string{choice}, result... )
					r_point = point
					// ベータカット
					if point <= param.Limit { 
						// fmt.Printf("%sbeta cut %v %d\n", strings.Repeat("  ", child_param.Level), child, point);
						break
					}
				}
			}
		}
	}else{
		r_choices = []string{}
		r_point = node.Point()
	}
	// fmt.Printf( "%ssolved: %s %d\n", strings.Repeat("  ", param.Level), r_node, r_point )
	return r_choices, r_point
}

func Solv( node Node ) ([]string, int) {
	param := Param{math.MaxInt32,0,10,true}
	return solvNode( param, node )
}
